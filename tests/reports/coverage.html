
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>ca: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/chutommy/eetgateway/pkg/ca/roots.go (73.7%)</option>
				
				<option value="file1">github.com/chutommy/eetgateway/pkg/eet/eet-gen.go (30.2%)</option>
				
				<option value="file2">github.com/chutommy/eetgateway/pkg/eet/eet.go (83.9%)</option>
				
				<option value="file3">github.com/chutommy/eetgateway/pkg/eet/envelope-tmpl.go (100.0%)</option>
				
				<option value="file4">github.com/chutommy/eetgateway/pkg/eet/envelope.go (77.2%)</option>
				
				<option value="file5">github.com/chutommy/eetgateway/pkg/eet/security-codes.go (94.4%)</option>
				
				<option value="file6">github.com/chutommy/eetgateway/pkg/fscr/certificate.go (75.0%)</option>
				
				<option value="file7">github.com/chutommy/eetgateway/pkg/fscr/client.go (79.3%)</option>
				
				<option value="file8">github.com/chutommy/eetgateway/pkg/gateway/service.go (62.5%)</option>
				
				<option value="file9">github.com/chutommy/eetgateway/pkg/keystore/keypair.go (80.7%)</option>
				
				<option value="file10">github.com/chutommy/eetgateway/pkg/keystore/service.go (79.8%)</option>
				
				<option value="file11">github.com/chutommy/eetgateway/pkg/server/httphandler/certificate.go (91.8%)</option>
				
				<option value="file12">github.com/chutommy/eetgateway/pkg/server/httphandler/handler.go (100.0%)</option>
				
				<option value="file13">github.com/chutommy/eetgateway/pkg/server/httphandler/health.go (100.0%)</option>
				
				<option value="file14">github.com/chutommy/eetgateway/pkg/server/httphandler/middlewares.go (35.3%)</option>
				
				<option value="file15">github.com/chutommy/eetgateway/pkg/server/httphandler/model.go (63.3%)</option>
				
				<option value="file16">github.com/chutommy/eetgateway/pkg/server/httphandler/sale.go (100.0%)</option>
				
				<option value="file17">github.com/chutommy/eetgateway/pkg/server/httphandler/validator.go (81.1%)</option>
				
				<option value="file18">github.com/chutommy/eetgateway/pkg/wsse/canonicalization.go (83.6%)</option>
				
				<option value="file19">github.com/chutommy/eetgateway/pkg/wsse/signature.go (75.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package ca

import (
        "crypto/x509"
        "encoding/pem"
        "fmt"
)

// ProductionRoots returns a CA EET root certificates for production purposes.
func ProductionRoots() ([]*x509.Certificate, error) <span class="cov8" title="1">{
        cert, err := parseCert(RootCAEET1Production)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse CA EET 1 Production certificate: %w", err)
        }</span>

        <span class="cov8" title="1">cert2025, err := parseCert(RootCAEET1Production2025)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse CA EET 1 Production 2025 certificate: %w", err)
        }</span>

        <span class="cov8" title="1">return []*x509.Certificate{cert, cert2025}, nil</span>
}

// PlaygroundRoots returns a CA EET root certificates for development purposes.
func PlaygroundRoots() ([]*x509.Certificate, error) <span class="cov8" title="1">{
        cert, err := parseCert(RootCAEET1Playground)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse CA EET 1 Playground certificate: %w", err)
        }</span>

        <span class="cov8" title="1">cert2025, err := parseCert(RootCAEET1Playground2025)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse CA EET 1 Playground 2025 certificate: %w", err)
        }</span>

        <span class="cov8" title="1">return []*x509.Certificate{cert, cert2025}, nil</span>
}

func parseCert(rawPEM []byte) (*x509.Certificate, error) <span class="cov8" title="1">{
        block, _ := pem.Decode(rawPEM)
        cert, err := x509.ParseCertificate(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse certificate: %w", err)
        }</span>

        <span class="cov8" title="1">return cert, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by wsdlgen. DO NOT EDIT.

// Package eet
//
package eet

import (
        "bytes"
        "context"
        "encoding/base64"
        "encoding/xml"
        "fmt"
        "io"
        "net/http"
        "time"
)

// May be one of SHA1
type BkpDigestType string

type BkpElementType struct {
        BkpType  BkpType         `xml:",chardata"`
        Digest   BkpDigestType   `xml:"digest,attr"`
        Encoding BkpEncodingType `xml:"encoding,attr"`
}

// May be one of base16
type BkpEncodingType string

// Must match the pattern [0-9a-fA-F]{8}-[0-9a-fA-F]{8}-[0-9a-fA-F]{8}-[0-9a-fA-F]{8}-[0-9a-fA-F]{8}
type BkpType string

// Must match the pattern CZ[0-9]{8,10}
type CZDICType string

// Must match the pattern ((0|-?[1-9]\d{0,7})\.\d\d|-0\.(0[1-9]|[1-9]\d))
type CastkaType float64

type DateTime time.Time

func (t *DateTime) UnmarshalText(text []byte) error <span class="cov8" title="1">{
        return (*xsdDateTime)(t).UnmarshalText(text)
}</span>
func (t DateTime) MarshalText() ([]byte, error) <span class="cov8" title="1">{
        return xsdDateTime(t).MarshalText()
}</span>

// Must match the pattern [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}-[0-9a-fA-F]{2}
type FikType string

type OdpovedChybaType struct {
        Zprava string `xml:",chardata"`
        Kod    int    `xml:"kod,attr"`
        Test   bool   `xml:"test,attr,omitempty"`
}

type OdpovedHlavickaType struct {
        Uuidzpravy UUIDType `xml:"uuid_zpravy,attr,omitempty"`
        Bkp        BkpType  `xml:"bkp,attr,omitempty"`
        Datprij    DateTime `xml:"dat_prij,attr,omitempty"`
        Datodmit   DateTime `xml:"dat_odmit,attr,omitempty"`
}

type OdpovedPotvrzeniType struct {
        Fik  FikType `xml:"fik,attr"`
        Test bool    `xml:"test,attr,omitempty"`
}

type OdpovedType struct {
        Hlavicka  OdpovedHlavickaType   `xml:"Hlavicka,omitempty"`
        Potvrzeni OdpovedPotvrzeniType  `xml:"Potvrzeni,omitempty"`
        Chyba     OdpovedChybaType      `xml:"Chyba,omitempty"`
        Varovani  []OdpovedVarovaniType `xml:"Varovani,omitempty"`
}

type OdpovedVarovaniType struct {
        Zprava   string `xml:",chardata"`
        Kodvarov int    `xml:"kod_varov,attr"`
}

// May be one of RSA2048
type PkpCipherType string

// May be one of SHA256
type PkpDigestType string

type PkpElementType struct {
        PkpType  PkpType         `xml:",chardata"`
        Digest   PkpDigestType   `xml:"digest,attr"`
        Cipher   PkpCipherType   `xml:"cipher,attr"`
        Encoding PkpEncodingType `xml:"encoding,attr"`
}

// May be one of base64
type PkpEncodingType string

type PkpType []byte

func (t *PkpType) UnmarshalText(text []byte) error <span class="cov8" title="1">{
        return (*xsdBase64Binary)(t).UnmarshalText(text)
}</span>
func (t PkpType) MarshalText() ([]byte, error) <span class="cov8" title="1">{
        return xsdBase64Binary(t).MarshalText()
}</span>

// May be one of 0, 1
type RezimType int

// Must match the pattern [0-9a-zA-Z\.,:;/#\-_ ]{1,20}
type String20 string

// Must match the pattern [0-9a-zA-Z\.,:;/#\-_ ]{1,25}
type String25 string

type TrzbaDataType struct {
        Dicpopl         CZDICType  `xml:"dic_popl,attr"`
        Dicpoverujiciho CZDICType  `xml:"dic_poverujiciho,attr,omitempty"`
        Idprovoz        int        `xml:"id_provoz,attr"`
        Idpokl          String20   `xml:"id_pokl,attr"`
        Poradcis        String25   `xml:"porad_cis,attr"`
        Dattrzby        DateTime   `xml:"dat_trzby,attr"`
        Celktrzba       CastkaType `xml:"celk_trzba,attr"`
        Zaklnepodldph   CastkaType `xml:"zakl_nepodl_dph,attr,omitempty"`
        Zakldan1        CastkaType `xml:"zakl_dan1,attr,omitempty"`
        Dan1            CastkaType `xml:"dan1,attr,omitempty"`
        Zakldan2        CastkaType `xml:"zakl_dan2,attr,omitempty"`
        Dan2            CastkaType `xml:"dan2,attr,omitempty"`
        Zakldan3        CastkaType `xml:"zakl_dan3,attr,omitempty"`
        Dan3            CastkaType `xml:"dan3,attr,omitempty"`
        Cestsluz        CastkaType `xml:"cest_sluz,attr,omitempty"`
        Pouzitzboz1     CastkaType `xml:"pouzit_zboz1,attr,omitempty"`
        Pouzitzboz2     CastkaType `xml:"pouzit_zboz2,attr,omitempty"`
        Pouzitzboz3     CastkaType `xml:"pouzit_zboz3,attr,omitempty"`
        Urcenocerpzuct  CastkaType `xml:"urceno_cerp_zuct,attr,omitempty"`
        Cerpzuct        CastkaType `xml:"cerp_zuct,attr,omitempty"`
        Rezim           RezimType  `xml:"rezim,attr"`
}

type TrzbaHlavickaType struct {
        Uuidzpravy   UUIDType `xml:"uuid_zpravy,attr"`
        Datodesl     DateTime `xml:"dat_odesl,attr"`
        Prvnizaslani bool     `xml:"prvni_zaslani,attr"`
        Overeni      bool     `xml:"overeni,attr,omitempty"`
}

type TrzbaKontrolniKodyType struct {
        Pkp PkpElementType `xml:"pkp"`
        Bkp BkpElementType `xml:"bkp"`
}

type TrzbaType struct {
        Hlavicka      TrzbaHlavickaType      `xml:"Hlavicka"`
        Data          TrzbaDataType          `xml:"Data"`
        KontrolniKody TrzbaKontrolniKodyType `xml:"KontrolniKody"`
}

// Must match the pattern [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}
type UUIDType string

type xsdBase64Binary []byte

func (b *xsdBase64Binary) UnmarshalText(text []byte) (err error) <span class="cov8" title="1">{
        *b, err = base64.StdEncoding.DecodeString(string(text))
        return
}</span>
func (b xsdBase64Binary) MarshalText() ([]byte, error) <span class="cov8" title="1">{
        var buf bytes.Buffer
        enc := base64.NewEncoder(base64.StdEncoding, &amp;buf)
        enc.Write([]byte(b))
        enc.Close()
        return buf.Bytes(), nil
}</span>

type xsdDateTime time.Time

func (t *xsdDateTime) UnmarshalText(text []byte) error <span class="cov8" title="1">{
        return _unmarshalTime(text, (*time.Time)(t), "2006-01-02T15:04:05.999999999")
}</span>
func (t xsdDateTime) MarshalText() ([]byte, error) <span class="cov8" title="1">{
        return _marshalTime((time.Time)(t), "2006-01-02T15:04:05.999999999")
}</span>
func (t xsdDateTime) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov0" title="0">{
        if (time.Time)(t).IsZero() </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">m, err := t.MarshalText()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return e.EncodeElement(m, start)</span>
}
func (t xsdDateTime) MarshalXMLAttr(name xml.Name) (xml.Attr, error) <span class="cov0" title="0">{
        if (time.Time)(t).IsZero() </span><span class="cov0" title="0">{
                return xml.Attr{}, nil
        }</span>
        <span class="cov0" title="0">m, err := t.MarshalText()
        return xml.Attr{Name: name, Value: string(m)}, err</span>
}
func _unmarshalTime(text []byte, t *time.Time, format string) (err error) <span class="cov8" title="1">{
        s := string(bytes.TrimSpace(text))
        *t, err = time.Parse(format, s)
        if _, ok := err.(*time.ParseError); ok </span><span class="cov8" title="1">{
                *t, err = time.Parse(format+"Z07:00", s)
        }</span>
        <span class="cov8" title="1">return err</span>
}
func _marshalTime(t time.Time, format string) ([]byte, error) <span class="cov8" title="1">{
        return []byte(t.Format(format + "Z07:00")), nil
}</span>

type Client struct {
        HTTPClient   *http.Client
        ResponseHook func(*http.Response) *http.Response
        RequestHook  func(*http.Request) *http.Request
}
type soapEnvelope struct {
        XMLName struct{} `xml:"http://schemas.xmlsoap.org/soap/envelope/ Envelope"`
        Header  []byte   `xml:"http://schemas.xmlsoap.org/soap/envelope/ Header"`
        Body    struct {
                Message interface{}
                Fault   *struct {
                        String string `xml:"faultstring,omitempty"`
                        Code   string `xml:"faultcode,omitempty"`
                        Detail string `xml:"detail,omitempty"`
                } `xml:"http://schemas.xmlsoap.org/soap/envelope/ Fault,omitempty"`
        } `xml:"http://schemas.xmlsoap.org/soap/envelope/ Body"`
}

func (c *Client) do(ctx context.Context, method, uri, action string, in, out interface{}) error <span class="cov0" title="0">{
        var body io.Reader
        var envelope soapEnvelope
        if method == "POST" || method == "PUT" </span><span class="cov0" title="0">{
                var buf bytes.Buffer
                envelope.Body.Message = in
                enc := xml.NewEncoder(&amp;buf)
                if err := enc.Encode(envelope); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := enc.Flush(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">body = &amp;buf</span>
        }
        <span class="cov0" title="0">req, err := http.NewRequest(method, uri, body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">req.Header.Set("SOAPAction", action)
        req = req.WithContext(ctx)
        if c.RequestHook != nil </span><span class="cov0" title="0">{
                req = c.RequestHook(req)
        }</span>
        <span class="cov0" title="0">httpClient := c.HTTPClient
        if httpClient == nil </span><span class="cov0" title="0">{
                httpClient = http.DefaultClient
        }</span>
        <span class="cov0" title="0">rsp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rsp.Body.Close()
        if c.ResponseHook != nil </span><span class="cov0" title="0">{
                rsp = c.ResponseHook(rsp)
        }</span>
        <span class="cov0" title="0">dec := xml.NewDecoder(rsp.Body)
        envelope.Body.Message = out
        if err := dec.Decode(&amp;envelope); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if envelope.Body.Fault != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %s", envelope.Body.Fault.Code, envelope.Body.Fault.String)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package eet

import (
        "crypto/rsa"
        "encoding/xml"
        "fmt"
        "time"

        "github.com/beevik/etree"
)

// DateTimeLayout is the datetime layout of the EET system.
const DateTimeLayout = time.RFC3339

// Normalize canonicalizes the DateTime data. All DateTime needs to be normalized.
func (t *DateTime) Normalize() <span class="cov0" title="0">{
        *t = DateTime(time.Time(*t).Truncate(time.Second))
}</span>

// MarshalText encodes CastkaType value to the correct form with two decimal places included.
func (c CastkaType) MarshalText() ([]byte, error) <span class="cov8" title="1">{
        return []byte(fmt.Sprintf("%.2f", float64(c))), nil
}</span>

func (t *TrzbaType) etree() (*etree.Element, error) <span class="cov8" title="1">{
        xmlTrzba, err := xml.Marshal(t)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("xml marshal trzba type content: %w", err)
        }</span>

        <span class="cov8" title="1">trzbaDoc := etree.NewDocument()
        if err = trzbaDoc.ReadFromBytes(xmlTrzba); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("load trzba data to etree document: %w", err)
        }</span>

        <span class="cov8" title="1">trzba := trzbaDoc.Root()
        // Overwrite the tag of value "TrzbaType".
        trzba.Tag = "Trzba"
        trzba.CreateAttr("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance")
        trzba.CreateAttr("xmlns:xsd", "http://www.w3.org/2001/XMLSchema")
        trzba.CreateAttr("xmlns", "http://fs.mfcr.cz/eet/schema/v3")

        return trzba, nil</span>
}

func (t *TrzbaType) setSecurityCodes(pk *rsa.PrivateKey) error <span class="cov8" title="1">{
        err := t.setPKP(pk)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set pkp: %w", err)
        }</span>

        <span class="cov8" title="1">t.setBKP(t.KontrolniKody.Pkp.PkpType)

        return nil</span>
}

func (t *TrzbaType) setPKP(pk *rsa.PrivateKey) error <span class="cov8" title="1">{
        pkp, err := pkp(t.plaintext(), pk)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("calculate PKP: %w", err)
        }</span>

        <span class="cov8" title="1">t.KontrolniKody.Pkp.Digest = "SHA256"
        t.KontrolniKody.Pkp.Cipher = "RSA2048"
        t.KontrolniKody.Pkp.Encoding = "base64"
        t.KontrolniKody.Pkp.PkpType = pkp

        return nil</span>
}

func (t *TrzbaType) plaintext() string <span class="cov8" title="1">{
        return fmt.Sprintf(
                "%s|%d|%s|%s|%s|%.2f",
                t.Data.Dicpopl,
                t.Data.Idprovoz,
                t.Data.Idpokl,
                t.Data.Poradcis,
                time.Time(t.Data.Dattrzby).Format(DateTimeLayout),
                t.Data.Celktrzba,
        )
}</span>

func (t *TrzbaType) setBKP(pkp PkpType) <span class="cov8" title="1">{
        t.KontrolniKody.Bkp.Digest = "SHA1"
        t.KontrolniKody.Bkp.Encoding = "base16"
        t.KontrolniKody.Bkp.BkpType = bkp(pkp)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package eet

import (
        "github.com/beevik/etree"
)

const (
        sXMLNS    = "s"
        wseXMLNS  = "wse"
        wsseXMLNS = "wsse"
)

var envelopeTmpl *etree.Document

func getSoapEnvelope() *etree.Document <span class="cov8" title="1">{
        if envelopeTmpl == nil </span><span class="cov8" title="1">{
                envelopeTmpl = buildSOAPEnvelope()
        }</span>

        <span class="cov8" title="1">return envelopeTmpl.Copy()</span>
}

func buildSOAPEnvelope() *etree.Document <span class="cov8" title="1">{
        doc := etree.NewDocument()
        doc.CreateProcInst("xml", `version="1.0" encoding="UTF-8"`)
        doc.SetRoot(buildEnvelope())

        return doc
}</span>

func buildEnvelope() *etree.Element <span class="cov8" title="1">{
        envelope := etree.NewElement("Envelope")
        envelope.Space = sXMLNS
        envelope.CreateAttr("xmlns:u", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd")
        envelope.CreateAttr("xmlns:s", "http://schemas.xmlsoap.org/soap/envelope/")
        envelope.AddChild(buildHeader())

        return envelope
}</span>

func buildHeader() *etree.Element <span class="cov8" title="1">{
        header := etree.NewElement("Header")
        header.Space = sXMLNS
        header.AddChild(buildSecurity())

        return header
}</span>

func buildSecurity() *etree.Element <span class="cov8" title="1">{
        security := etree.NewElement("Security")
        security.Space = wsseXMLNS
        security.CreateAttr("xmlns:wsse", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd")
        security.AddChild(buildBinarySecurityToken())
        security.AddChild(buildSignature())

        return security
}</span>

func buildBinarySecurityToken() *etree.Element <span class="cov8" title="1">{
        token := etree.NewElement("BinarySecurityToken")
        token.Space = wseXMLNS
        token.CreateAttr("xmlns:wse", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd")
        token.CreateAttr("EncodingType", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary")
        token.CreateAttr("ValueType", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3")
        token.CreateAttr("u:Id", "BinaryToken1")

        return token
}</span>

func buildSignature() *etree.Element <span class="cov8" title="1">{
        signature := etree.NewElement("Signature")
        signature.CreateAttr("xmlns", "http://www.w3.org/2000/09/xmldsig#")
        signature.AddChild(buildSignedInfo())
        signature.CreateElement("SignatureValue")
        signature.AddChild(buildKeyInfo())

        return signature
}</span>

func buildSignedInfo() *etree.Element <span class="cov8" title="1">{
        signedInfo := etree.NewElement("SignedInfo")
        signedInfo.CreateElement("CanonicalizationMethod").CreateAttr("Algorithm", "http://www.w3.org/2001/10/xml-exc-c14n#")
        signedInfo.CreateElement("SignatureMethod").CreateAttr("Algorithm", "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256")
        signedInfo.AddChild(buildReference())

        return signedInfo
}</span>

func buildReference() *etree.Element <span class="cov8" title="1">{
        reference := etree.NewElement("Reference")
        reference.CreateAttr("URI", "#_1")
        reference.CreateElement("Transforms").CreateElement("Transform").CreateAttr("Algorithm", "http://www.w3.org/2001/10/xml-exc-c14n#")
        reference.CreateElement("DigestMethod").CreateAttr("Algorithm", "http://www.w3.org/2001/04/xmlenc#sha256")
        reference.CreateElement("DigestValue")

        return reference
}</span>

func buildKeyInfo() *etree.Element <span class="cov8" title="1">{
        keyInfo := etree.NewElement("KeyInfo")
        securityTokenReference := keyInfo.CreateElement("SecurityTokenReference")
        securityTokenReference.Space = wseXMLNS
        securityTokenReference.CreateAttr("xmlns:wse", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd")
        tokenReference := securityTokenReference.CreateElement("Reference")
        tokenReference.Space = wseXMLNS
        tokenReference.CreateAttr("URI", "#BinaryToken1")
        tokenReference.CreateAttr("ValueType", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509")

        return keyInfo
}</span>

func buildBodyElem() *etree.Element <span class="cov8" title="1">{
        body := etree.NewElement("Body")
        body.CreateAttr("xmlns:u", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd")
        body.CreateAttr("xmlns:s", "http://schemas.xmlsoap.org/soap/envelope/")
        body.CreateAttr("u:Id", "_1")
        body.Space = sXMLNS

        return body
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package eet

import (
        "crypto"
        "crypto/rsa"
        "crypto/x509"
        "encoding/base64"
        "encoding/xml"
        "errors"
        "fmt"

        "github.com/beevik/etree"
        "github.com/chutommy/eetgateway/pkg/wsse"
)

// ErrInvalidXMLDigest is returned if the referenced computed digest differs from the digest in the XML.
var ErrInvalidXMLDigest = errors.New("computed digest differs from the digest in the XML")

// ErrInvalidSOAPMessage is returned if a SOAP message has an unexpected structure.
var ErrInvalidSOAPMessage = errors.New("SOAP message with an unexpected structure")

// ErrInvalidUUID is returned if the response UUID is different, or it has invalid format.
var ErrInvalidUUID = errors.New("invalid UUID value or format")

// ErrInvalidBKP is returned if the response BKP code is different.
var ErrInvalidBKP = errors.New("incorrect response BKP")

// NewRequestEnvelope returns a populated and signed SOAP request envelope.
func NewRequestEnvelope(t *TrzbaType, cert *x509.Certificate, pk *rsa.PrivateKey) ([]byte, error) <span class="cov8" title="1">{
        if err := t.setSecurityCodes(pk); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("setting security codes: %w", err)
        }</span>

        <span class="cov8" title="1">trzba, err := t.etree()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshal trzba to etree element: %w", err)
        }</span>

        <span class="cov8" title="1">binCert, err := certToB64(cert)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("convert certificate to base64: %w", err)
        }</span>

        // build request message
        <span class="cov8" title="1">body := buildBodyElem()
        body.AddChild(trzba)
        env := getSoapEnvelope()
        envElem, err := findElement(env.Root(), ".")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">envElem.AddChild(body)

        // set binary security token
        tokenElem, err := findElement(envElem, "./Header/Security/BinarySecurityToken")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">tokenElem.SetText(string(binCert))

        // set signature
        signature, err := findElement(env.Root(), "./Header/Security/Signature")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err = setDigestVal(body, signature); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("set digest value: %w", err)
        }</span>

        <span class="cov8" title="1">if err = setSignatureVal(pk, signature); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("set signature value: %w", err)
        }</span>

        <span class="cov8" title="1">signedEnv, err := env.WriteToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse envelope document to bytes: %w", err)
        }</span>

        <span class="cov8" title="1">return signedEnv, nil</span>
}

func certToB64(cert *x509.Certificate) ([]byte, error) <span class="cov8" title="1">{
        b64 := make([]byte, base64.StdEncoding.EncodedLen(len(cert.Raw)))
        base64.StdEncoding.Encode(b64, cert.Raw)
        return b64, nil
}</span>

func setDigestVal(body *etree.Element, sign *etree.Element) error <span class="cov8" title="1">{
        digest, err := wsse.CalcDigest(body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("calculate digest of the body element: %w", err)
        }</span>

        <span class="cov8" title="1">digestVal := base64.StdEncoding.EncodeToString(digest)
        digestValElem, err := findElement(sign, "./SignedInfo/Reference/DigestValue")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">digestValElem.SetText(digestVal)

        return nil</span>
}

func setSignatureVal(pk *rsa.PrivateKey, signature *etree.Element) error <span class="cov8" title="1">{
        signedInfo, err := findElement(signature, "./SignedInfo")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">rawSig, err := wsse.CalcSignature(pk, signedInfo.Copy())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("calculate signature value: %w", err)
        }</span>

        <span class="cov8" title="1">sigVal := base64.StdEncoding.EncodeToString(rawSig)
        sigValElem, err := findElement(signature, "./SignatureValue")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">sigValElem.SetText(sigVal)

        return nil</span>
}

// OdpovedBody represents a SOAP Body of the response envelope.
type OdpovedBody struct {
        Odpoved OdpovedType `xml:"Odpoved"`
}

// ParseResponseEnvelope returns a parsed SOAP response envelope.
func ParseResponseEnvelope(env []byte) (*OdpovedType, error) <span class="cov8" title="1">{
        doc := etree.NewDocument()
        err := doc.ReadFromBytes(env)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("parse envelope to etree: %w", err)
        }</span>

        <span class="cov8" title="1">bodyElem, err := findElement(doc.Root(), "./Body")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">doc.SetRoot(bodyElem.Copy())
        odpovedBytes, err := doc.WriteToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("serialize etree document to bytes: %w", err)
        }</span>

        <span class="cov8" title="1">var odpoved OdpovedBody
        err = xml.Unmarshal(odpovedBytes, &amp;odpoved)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("decode odpoved bytes: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;odpoved.Odpoved, nil</span>
}

// VerifyResponse checks whether the response envelope is valid and is signed by a trusted certificate.
func VerifyResponse(trzba *TrzbaType, respEnv []byte, odpoved *OdpovedType, verifyCert func(*x509.Certificate) error) error <span class="cov8" title="1">{
        envelope := etree.NewDocument()
        err := envelope.ReadFromBytes(respEnv)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("parse envelope to etree: %w", err)
        }</span>

        // verify only if successful
        <span class="cov8" title="1">if !trzba.Hlavicka.Overeni &amp;&amp; odpoved.Chyba.Kod == 0 </span><span class="cov8" title="1">{
                if trzba.Hlavicka.Uuidzpravy != odpoved.Hlavicka.Uuidzpravy </span><span class="cov0" title="0">{
                        return fmt.Errorf("different uuid: %w", ErrInvalidUUID)
                }</span>

                <span class="cov8" title="1">if trzba.KontrolniKody.Bkp.BkpType != odpoved.Hlavicka.Bkp </span><span class="cov8" title="1">{
                        return fmt.Errorf("different bkp: %w", ErrInvalidBKP)
                }</span>

                <span class="cov8" title="1">if err := checkDigSig(envelope); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("check digital signature: %w", err)
                }</span>

                <span class="cov8" title="1">if err := verifyCertificate(envelope, verifyCert); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("check certificate: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func verifyCertificate(envelope *etree.Document, verifyCert func(*x509.Certificate) error) error <span class="cov8" title="1">{
        tokenElem, err := findElement(envelope.Root(), "./Header/Security/BinarySecurityToken")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">tokenB64 := tokenElem.Text()
        rawCert, err := base64.StdEncoding.DecodeString(tokenB64)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("decode binary security token from base64 encoding: %w", err)
        }</span>

        <span class="cov8" title="1">cert, err := x509.ParseCertificate(rawCert)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("parse raw certificate: %w", err)
        }</span>

        <span class="cov8" title="1">if err = verifyCert(cert); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("verify security token: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func checkDigSig(envelope *etree.Document) error <span class="cov8" title="1">{
        if err := validateDigestValue(envelope); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid digest value: %w", err)
        }</span>

        <span class="cov8" title="1">if err := verifySignature(envelope); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("verify signature: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func verifySignature(envelope *etree.Document) error <span class="cov8" title="1">{
        cert, err := getCertFromToken(envelope)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("retrieve certificate from the binary security token: %w", err)
        }</span>

        <span class="cov8" title="1">sigVal, digest, err := getSignatureDate(envelope)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("retrieve signature value and digest: %w", err)
        }</span>

        <span class="cov8" title="1">err = rsa.VerifyPKCS1v15(cert.PublicKey.(*rsa.PublicKey), crypto.SHA256, digest, sigVal)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("verify PKCS1v15 signature: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func getSignatureDate(envelope *etree.Document) (sigVal []byte, digest []byte, err error) <span class="cov8" title="1">{
        sigElem, err := findElement(envelope.Root(), "./Header/Security/Signature")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // signature value
        <span class="cov8" title="1">{
                sigValElem, err := findElement(sigElem, "./SignatureValue")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>

                <span class="cov8" title="1">sigValB64 := sigValElem.Text()
                sigVal, err = base64.StdEncoding.DecodeString(sigValB64)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("decode base64 signature value: %w", err)
                }</span>
        }

        // digest value
        <span class="cov8" title="1">{
                signedInfo, err := findElement(sigElem, "./SignedInfo")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>

                // namespace for the XML digital signature
                <span class="cov8" title="1">signedInfo.CreateAttr("xmlns", "http://www.w3.org/2000/09/xmldsig#")

                digest, err = wsse.CalcDigest(signedInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("calculate digest value of signed info: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return sigVal, digest, nil</span>
}

func getCertFromToken(envelope *etree.Document) (*x509.Certificate, error) <span class="cov8" title="1">{
        tokenElem, err := findElement(envelope.Root(), "./Header/Security/BinarySecurityToken")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">token := tokenElem.Text()
        rawCert, _ := base64.StdEncoding.DecodeString(token)
        cert, err := x509.ParseCertificate(rawCert)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse x509 certificate: %w", err)
        }</span>

        <span class="cov8" title="1">return cert, nil</span>
}

func validateDigestValue(envelope *etree.Document) error <span class="cov8" title="1">{
        digest, err := bodyDigest(envelope)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("get digest value of the body element: %w", err)
        }</span>

        <span class="cov8" title="1">digestValElem, err := findElement(envelope.Root(), "./Header/Security/Signature/SignedInfo/Reference/DigestValue")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">expDigestVal := base64.StdEncoding.EncodeToString(digest)
        actDigestVal := digestValElem.Text()

        if expDigestVal != actDigestVal </span><span class="cov8" title="1">{
                return ErrInvalidXMLDigest
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func bodyDigest(envelope *etree.Document) ([]byte, error) <span class="cov8" title="1">{
        bodyElem, err := findElement(envelope.Root(), "./Body")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // set namespaces
        <span class="cov8" title="1">bodyElem.CreateAttr("xmlns:eet", "http://fs.mfcr.cz/eet/schema/v3")
        bodyElem.CreateAttr("xmlns:soapenv", "http://schemas.xmlsoap.org/soap/envelope/")
        bodyElem.CreateAttr("xmlns:wsu", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd")

        digest, _ := wsse.CalcDigest(bodyElem)

        return digest, nil</span>
}

func findElement(root *etree.Element, path string) (*etree.Element, error) <span class="cov8" title="1">{
        e := root.FindElement(path)
        if e == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("element in %s of %s element not found: %w", path, root.FullTag(), ErrInvalidSOAPMessage)
        }</span>

        <span class="cov8" title="1">return e, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package eet

import (
        "crypto"
        "crypto/rand"
        "crypto/rsa"
        "crypto/sha1" //nolint:gosec
        "crypto/sha256"
        "encoding/hex"
        "fmt"
)

func pkp(plaintext string, pk *rsa.PrivateKey) ([]byte, error) <span class="cov8" title="1">{
        digest := sha256.Sum256([]byte(plaintext))
        pkp, err := rsa.SignPKCS1v15(rand.Reader, pk, crypto.SHA256, digest[:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("signing PKP: %w", err)
        }</span>

        <span class="cov8" title="1">return pkp, err</span>
}

func bkp(pkp PkpType) BkpType <span class="cov8" title="1">{
        digest := sha1.Sum(pkp) //nolint:gosec
        bkpB16 := hex.EncodeToString(digest[:])
        bkpB16B := []byte(bkpB16)
        bkp := setDelimiters(bkpB16B)

        return BkpType(bkp)
}</span>

func setDelimiters(bkpB16B []byte) []byte <span class="cov8" title="1">{
        bkp := make([]byte, 44)
        delims := 0
        for i, c := range bkpB16B </span><span class="cov8" title="1">{
                if (i+delims)%9 == 8 </span><span class="cov8" title="1">{
                        bkp[i+delims] = '-'
                        delims++
                }</span>

                <span class="cov8" title="1">bkp[i+delims] = c</span>
        }

        <span class="cov8" title="1">return bkp</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package fscr

import (
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "errors"
        "fmt"

        "go.uber.org/multierr"
        "golang.org/x/crypto/pkcs12"
)

// ErrInvalidOrganizationName is returned if the organization name of a certificate is invalid.
var ErrInvalidOrganizationName = errors.New("invalid organization name")

// ErrNotCACertificate is returned if a non-CA's certificate is provided where the one is being expected.
var ErrNotCACertificate = errors.New("not CA's certificate")

// ErrInvalidKeyPair is returned if a certificate/private-key KeyPair is invalid.
var ErrInvalidKeyPair = errors.New("invalid certificate/private-key KeyPair")

// ErrInvalidCertificate is returned if a given certificate or private key is invalid.
var ErrInvalidCertificate = errors.New("invalid certificate or private key")

// ErrNotTrustedCertificate is returned if a certificate is issued or signed by an unknown authority
// and can't be trusted.
var ErrNotTrustedCertificate = errors.New("certificate issued or signed by an unknown authority")

// OrganizationName is the legal name that the organization is registered with authority at the national level.
const OrganizationName = "Česká republika - Generální finanční ředitelství"

// CAService verifies certificates signed off by trusted CAs.
type CAService interface {
        VerifyDSig(cert *x509.Certificate) error
        ParseTaxpayerCertificate(data []byte, password string) (*x509.Certificate, *rsa.PrivateKey, error)
}

type caService struct {
        eetCARoots []*x509.Certificate
        dsigPool   *x509.CertPool
}

// NewCAService returns a CAService implementation with the given certificate pools for
// verifying both issued taxpayers' certificates and digital signatures.
func NewCAService(eetRoots []*x509.Certificate, dsigPool *x509.CertPool) CAService <span class="cov8" title="1">{
        return &amp;caService{
                eetCARoots: eetRoots,
                dsigPool:   dsigPool,
        }
}</span>

// VerifyDSig verifies certificate used for the digital signature.
func (c *caService) VerifyDSig(cert *x509.Certificate) error <span class="cov8" title="1">{
        if n := cert.Subject.Organization[0]; n != OrganizationName </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected organization name (%s): %w", n, ErrInvalidOrganizationName)
        }</span>

        <span class="cov8" title="1">opts := x509.VerifyOptions{
                Roots: c.dsigPool,
                KeyUsages: []x509.ExtKeyUsage{
                        x509.ExtKeyUsageAny,
                },
        }

        if _, err := cert.Verify(opts); err != nil </span><span class="cov8" title="1">{
                return multierr.Append(fmt.Errorf("verify digital signature certificate: %w", err), ErrNotTrustedCertificate)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ParseTaxpayerCertificate takes a raw data of a PFX file and decodes it into PEM blocks.
// Blocks are expected to be in this order: taxpayer's certificate, certificate authority's certificate
// and private key. CA's certificate is used to verify taxpayer's certificate. The taxpayer's certificate
// and the private key must be a valid KeyPair.
func (c *caService) ParseTaxpayerCertificate(data []byte, password string) (*x509.Certificate, *rsa.PrivateKey, error) <span class="cov8" title="1">{
        blocks, err := pkcs12.ToPEM(data, password)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, multierr.Append(fmt.Errorf("convert PFX data to PEM blocks: %w", err), ErrInvalidCertificate)
        }</span>

        <span class="cov8" title="1">cert, caCert, pk, err := parsePEMBlocks(blocks)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, multierr.Append(fmt.Errorf("parse PEM blocks: %w", err), ErrInvalidCertificate)
        }</span>

        <span class="cov8" title="1">if err = verifyEETCA(c.eetCARoots, caCert); err != nil </span><span class="cov0" title="0">{
                return nil, nil, multierr.Append(fmt.Errorf("verify taxpayer's certificate CA: %w", err), ErrInvalidCertificate)
        }</span>

        <span class="cov8" title="1">err = verifyKeys(caCert, cert, pk)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, multierr.Append(fmt.Errorf("verify keys of the certificate: %w", err), ErrInvalidCertificate)
        }</span>

        <span class="cov8" title="1">return cert, pk, nil</span>
}

func parsePEMBlocks(blocks []*pem.Block) (cert *x509.Certificate, caCert *x509.Certificate, pk *rsa.PrivateKey, err error) <span class="cov8" title="1">{
        cert, err = x509.ParseCertificate(blocks[0].Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("parse taxpayer's certificate: %w", err)
        }</span>

        <span class="cov8" title="1">caCert, err = x509.ParseCertificate(blocks[1].Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("parse certificate authority's certificate: %w", err)
        }</span>

        <span class="cov8" title="1">pk, err = x509.ParsePKCS1PrivateKey(blocks[2].Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("parse taxpayer's private key: %w", err)
        }</span>

        <span class="cov8" title="1">return cert, caCert, pk, nil</span>
}

// verifyEETCA verifies a root certificate used for issuing taxpayers' certificates.
func verifyEETCA(roots []*x509.Certificate, cert *x509.Certificate) error <span class="cov8" title="1">{
        var ok bool
        // iterate over stored CA's root certificates
        for _, root := range roots </span><span class="cov8" title="1">{
                if cert.Equal(root) </span><span class="cov8" title="1">{
                        ok = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("certificate not found in a pool of valid EET CA certificates: %w", ErrNotTrustedCertificate)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func verifyKeys(caCert *x509.Certificate, cert *x509.Certificate, pk *rsa.PrivateKey) error <span class="cov8" title="1">{
        if isCa := caCert.IsCA; !isCa </span><span class="cov0" title="0">{
                return fmt.Errorf("expected CA's certificate: %w", ErrNotCACertificate)
        }</span>

        <span class="cov8" title="1">if err := cert.CheckSignatureFrom(caCert); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("taxpayer's certificate not signed off by the CA's certificate: %w", err)
        }</span>

        <span class="cov8" title="1">if !pk.PublicKey.Equal(cert.PublicKey) </span><span class="cov0" title="0">{
                return fmt.Errorf("the KeyPair of the taxpayer's private key and the certificate is not valid: %w", ErrInvalidKeyPair)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package fscr

import (
        "bytes"
        "context"
        "fmt"
        "io/ioutil"
        "net/http"

        "go.uber.org/multierr"
)

// ProductionURL is the URL of the production EET system.
const ProductionURL = "https://prod.eet.cz/eet/services/EETServiceSOAP/v3"

// PlaygroundURL is the URL of the playground EET system.
const PlaygroundURL = "https://pg.eet.cz/eet/services/EETServiceSOAP/v3"

const soapAction = "http://fs.mfcr.cz/eet/OdeslaniTrzby"

// Client represents a client to communicate with the FSCR servers.
type Client interface {
        Ping() error
        Do(ctx context.Context, reqBody []byte) ([]byte, error)
}

type client struct {
        c   *http.Client
        url string
}

// NewClient returns a Client implementation.
func NewClient(c *http.Client, url string) Client <span class="cov8" title="1">{
        return &amp;client{
                c:   c,
                url: url,
        }
}</span>

// Ping pings the host and returns the status code of the HTTP response.
func (c *client) Ping() error <span class="cov8" title="1">{
        resp, err := c.c.Head(c.url)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("ping %s: %w", c.url, err)
        }</span>
        <span class="cov8" title="1">defer multierr.AppendInvoke(&amp;err, multierr.Close(resp.Body))

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("status code not OK (200): %s", http.StatusText(resp.StatusCode))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Do makes a valid SOAP request to the FSCR servers with the request body reqBody and
// redirects the response body to respBody.
func (c *client) Do(ctx context.Context, reqBody []byte) (respBody []byte, err error) <span class="cov8" title="1">{
        req, err := createRequest(ctx, c.url, reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("construct http request: %w", err)
        }</span>

        <span class="cov8" title="1">resp, err := c.doHTTP(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("handle request: %w", err)
        }</span>
        <span class="cov8" title="1">defer multierr.AppendInvoke(&amp;err, multierr.Close(resp.Body))

        respBody, err = ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read response body: %w", err)
        }</span>

        <span class="cov8" title="1">return respBody, err</span>
}

func (c *client) doHTTP(req *http.Request) (*http.Response, error) <span class="cov8" title="1">{
        resp, err := c.c.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("send request: %w", err)
        }</span>

        <span class="cov8" title="1">return resp, nil</span>
}

func createRequest(ctx context.Context, url string, reqBody []byte) (*http.Request, error) <span class="cov8" title="1">{
        req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewReader(reqBody))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create a new http request: %w", err)
        }</span>

        <span class="cov8" title="1">req.Header.Set("SOAPAction", soapAction)
        req.Header.Set("Content-Type", "text/xml; charset=\"utf-8\"")

        return req, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package gateway

import (
        "context"
        "errors"

        "github.com/chutommy/eetgateway/pkg/eet"
        "github.com/chutommy/eetgateway/pkg/fscr"
        "github.com/chutommy/eetgateway/pkg/keystore"
        "go.uber.org/multierr"
)

// ErrCertificateNotFound is returned if a certificate with the given ID can't be found.
var ErrCertificateNotFound = errors.New("taxpayer's certificate not found")

// ErrIDAlreadyExists is returned if a certificate with the given ID already exists.
var ErrIDAlreadyExists = errors.New("taxpayer's certificate with the id already exists")

// ErrCertificateParse is returned if a certificate can't be parsed.
var ErrCertificateParse = errors.New("taxpayer's certificate not parsable")

// ErrInvalidCertificatePassword is returned if the given password can't open sealed certificate and private key.
var ErrInvalidCertificatePassword = errors.New("invalid password for the decryption of the taxpayer's certificate")

// ErrRequestBuild is returned if a SOAP request envelope can't be built.
var ErrRequestBuild = errors.New("SOAP request to FSCR not completed")

// ErrFSCRConnection is returned if an error occurs during the communication with the FSCR servers.
var ErrFSCRConnection = errors.New("bad FSCR connection")

// ErrFSCRResponseParse is returned if an error occurs during the FSCR SOAP response parsing.
var ErrFSCRResponseParse = errors.New("invalid FSCR response structure")

// ErrFSCRResponseVerify is returned if the response doesn't pass security checks and verifications.
var ErrFSCRResponseVerify = errors.New("FSCR response not verified")

// ErrInvalidTaxpayersCertificate is returned if an invalid taxpayer's certificate is given.
var ErrInvalidTaxpayersCertificate = errors.New("invalid taxpayer's certificate")

// ErrMaxTXAttempts is returned if the maximum number of transaction attempts is reached.
var ErrMaxTXAttempts = errors.New("request discarded caused by maximum transaction attempts")

// ErrKeystoreUnavailable is returned if the keystore service can't be reached.
var ErrKeystoreUnavailable = errors.New("keystore service unavailable")

// ErrKeystoreUnexpected is returned if an unexpected error occurs.
var ErrKeystoreUnexpected = errors.New("unexpected keystore error")

// Service handles all functionalities provided by the EET Gateway.
type Service interface {
        Ping(ctx context.Context) error
        SendSale(ctx context.Context, certID string, pk []byte, trzba *eet.TrzbaType) (*eet.OdpovedType, error)
        StoreCert(ctx context.Context, certID string, password []byte, pkcsData []byte, pkcsPassword string) error
        ListCertIDs(ctx context.Context, start, end int64) ([]string, error)
        UpdateCertID(ctx context.Context, oldID, newID string) error
        UpdateCertPassword(ctx context.Context, id string, oldPassword, newPassword []byte) error
        DeleteID(ctx context.Context, id string) error
}

type service struct {
        fscrClient fscr.Client
        caSvc      fscr.CAService
        keyStore   keystore.Service
}

// Ping checks whether the FSCR servers are online. It returns nil if the response status is OK.
func (g *service) Ping(ctx context.Context) (err error) <span class="cov8" title="1">{
        if e := g.fscrClient.Ping(); e != nil </span><span class="cov8" title="1">{
                err = multierr.Append(err, ErrFSCRConnection)
        }</span>

        <span class="cov8" title="1">if e := g.keyStore.Ping(ctx); e != nil </span><span class="cov8" title="1">{
                err = multierr.Append(err, ErrKeystoreUnavailable)
        }</span>

        <span class="cov8" title="1">return err</span>
}

// SendSale sends TrzbaType using fscr.Client, validates and verifies response and returns OdpovedType.
func (g *service) SendSale(ctx context.Context, certID string, certPassword []byte, trzba *eet.TrzbaType) (*eet.OdpovedType, error) <span class="cov0" title="0">{
        kp, err := g.keyStore.Get(ctx, certID, certPassword)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, keystore.ErrRecordNotFound):<span class="cov0" title="0">
                        return nil, multierr.Append(err, ErrCertificateNotFound)</span>
                case errors.Is(err, keystore.ErrInvalidDecryptionKey):<span class="cov0" title="0">
                        return nil, multierr.Append(err, ErrInvalidCertificatePassword)</span>
                case errors.Is(err, keystore.ErrReachedMaxAttempts):<span class="cov0" title="0">
                        return nil, multierr.Append(err, ErrMaxTXAttempts)</span>
                case g.keyStore.Ping(ctx) != nil:<span class="cov0" title="0">
                        return nil, multierr.Append(err, ErrKeystoreUnavailable)</span>
                }

                <span class="cov0" title="0">return nil, multierr.Append(err, ErrKeystoreUnexpected)</span>
        }

        <span class="cov0" title="0">reqEnv, err := eet.NewRequestEnvelope(trzba, kp.Cert, kp.PK)
        if err != nil </span><span class="cov0" title="0">{
                return nil, multierr.Append(err, ErrRequestBuild)
        }</span>

        <span class="cov0" title="0">respEnv, err := g.fscrClient.Do(ctx, reqEnv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, multierr.Append(err, ErrFSCRConnection)
        }</span>

        <span class="cov0" title="0">odpoved, err := eet.ParseResponseEnvelope(respEnv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, multierr.Append(err, ErrFSCRResponseParse)
        }</span>

        <span class="cov0" title="0">err = eet.VerifyResponse(trzba, respEnv, odpoved, g.caSvc.VerifyDSig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, multierr.Append(err, ErrFSCRResponseVerify)
        }</span>

        <span class="cov0" title="0">return odpoved, nil</span>
}

// StoreCert verifies and stores the taxpayer's certificate.
func (g *service) StoreCert(ctx context.Context, id string, password []byte, pkcsData []byte, pkcsPassword string) error <span class="cov8" title="1">{
        cert, pk, err := g.caSvc.ParseTaxpayerCertificate(pkcsData, pkcsPassword)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, fscr.ErrInvalidCertificate) </span><span class="cov8" title="1">{
                        return multierr.Append(err, ErrInvalidTaxpayersCertificate)
                }</span>

                <span class="cov8" title="1">return multierr.Append(err, ErrCertificateParse)</span>
        }

        <span class="cov8" title="1">err = g.keyStore.Store(ctx, id, password, &amp;keystore.KeyPair{
                Cert: cert,
                PK:   pk,
        })
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, keystore.ErrIDAlreadyExists):<span class="cov8" title="1">
                        return multierr.Append(err, ErrIDAlreadyExists)</span>
                case errors.Is(err, keystore.ErrReachedMaxAttempts):<span class="cov8" title="1">
                        return multierr.Append(err, ErrMaxTXAttempts)</span>
                case g.keyStore.Ping(ctx) != nil:<span class="cov0" title="0">
                        return multierr.Append(err, ErrKeystoreUnavailable)</span>
                }

                <span class="cov8" title="1">return multierr.Append(err, ErrKeystoreUnexpected)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ListCertIDs returns the list of all certificate IDs in the keystore.
func (g *service) ListCertIDs(ctx context.Context, start, end int64) ([]string, error) <span class="cov8" title="1">{
        ids, err := g.keyStore.List(ctx, start, end)
        if err != nil </span><span class="cov8" title="1">{
                if g.keyStore.Ping(ctx) != nil </span><span class="cov0" title="0">{
                        return nil, multierr.Append(err, ErrKeystoreUnavailable)
                }</span>

                <span class="cov8" title="1">return nil, multierr.Append(err, ErrKeystoreUnexpected)</span>
        }

        <span class="cov8" title="1">return ids, nil</span>
}

// UpdateCertID updates the ID of the certificate.
func (g *service) UpdateCertID(ctx context.Context, oldID, newID string) error <span class="cov8" title="1">{
        err := g.keyStore.UpdateID(ctx, oldID, newID)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, keystore.ErrRecordNotFound):<span class="cov8" title="1">
                        return multierr.Append(err, ErrCertificateNotFound)</span>
                case errors.Is(err, keystore.ErrIDAlreadyExists):<span class="cov8" title="1">
                        return multierr.Append(err, ErrIDAlreadyExists)</span>
                case errors.Is(err, keystore.ErrReachedMaxAttempts):<span class="cov8" title="1">
                        return multierr.Append(err, ErrMaxTXAttempts)</span>
                case g.keyStore.Ping(ctx) != nil:<span class="cov0" title="0">
                        return multierr.Append(err, ErrKeystoreUnavailable)</span>
                }

                <span class="cov8" title="1">return multierr.Append(err, ErrKeystoreUnexpected)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// UpdateCertPassword updates the password of the certificate.
func (g *service) UpdateCertPassword(ctx context.Context, id string, oldPassword, newPassword []byte) error <span class="cov8" title="1">{
        err := g.keyStore.UpdatePassword(ctx, id, oldPassword, newPassword)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, keystore.ErrRecordNotFound):<span class="cov8" title="1">
                        return multierr.Append(err, ErrCertificateNotFound)</span>
                case errors.Is(err, keystore.ErrInvalidDecryptionKey):<span class="cov8" title="1">
                        return multierr.Append(err, ErrInvalidCertificatePassword)</span>
                case errors.Is(err, keystore.ErrReachedMaxAttempts):<span class="cov8" title="1">
                        return multierr.Append(err, ErrMaxTXAttempts)</span>
                case g.keyStore.Ping(ctx) != nil:<span class="cov0" title="0">
                        return multierr.Append(err, ErrKeystoreUnavailable)</span>
                }

                <span class="cov8" title="1">return multierr.Append(err, ErrKeystoreUnexpected)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// DeleteID removes a certificate with the given ID.
func (g *service) DeleteID(ctx context.Context, id string) error <span class="cov8" title="1">{
        err := g.keyStore.Delete(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, keystore.ErrRecordNotFound):<span class="cov8" title="1">
                        return multierr.Append(err, ErrCertificateNotFound)</span>
                case errors.Is(err, keystore.ErrReachedMaxAttempts):<span class="cov0" title="0">
                        return multierr.Append(err, ErrMaxTXAttempts)</span>
                case g.keyStore.Ping(ctx) != nil:<span class="cov0" title="0">
                        return multierr.Append(err, ErrKeystoreUnavailable)</span>
                }

                <span class="cov8" title="1">return multierr.Append(err, ErrKeystoreUnexpected)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// NewService returns Service implementation.
func NewService(fscrClient fscr.Client, eetCASvc fscr.CAService, keyStore keystore.Service) Service <span class="cov8" title="1">{
        return &amp;service{
                fscrClient: fscrClient,
                caSvc:      eetCASvc,
                keyStore:   keyStore,
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package keystore

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "crypto/rsa"
        "crypto/sha256"
        "crypto/x509"
        "encoding/pem"
        "errors"
        "fmt"
        "io"

        "go.uber.org/multierr"
)

// ErrInvalidDecryptionKey is returned if the given password for the decryption is invalid and can't be used.
var ErrInvalidDecryptionKey = errors.New("given password can't decrypt the message")

// KeyPair represents a combination of a certificate and a private key.
type KeyPair struct {
        Cert *x509.Certificate
        PK   *rsa.PrivateKey
}

func (kp *KeyPair) encrypt(password, salt []byte) (cert []byte, pk []byte, err error) <span class="cov8" title="1">{
        gcm, err := gcmCipher(salt, password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("generate GCM: %w", err)
        }</span>

        // encrypt certificate
        <span class="cov8" title="1">derCert := kp.Cert.Raw
        cert, err = encryptPEMWithGCM(gcm, "CERTIFICATE", derCert)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("encrypt certificate with GCM: %w", err)
        }</span>

        // encrypt private key
        <span class="cov8" title="1">derPK := x509.MarshalPKCS1PrivateKey(kp.PK)
        pk, err = encryptPEMWithGCM(gcm, "RSA PRIVATE KEY", derPK)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("encrypt private key with GCM: %w", err)
        }</span>

        <span class="cov8" title="1">return cert, pk, nil</span>
}

func encryptPEMWithGCM(gcm cipher.AEAD, pemType string, data []byte) ([]byte, error) <span class="cov8" title="1">{
        pemData := pem.EncodeToMemory(&amp;pem.Block{
                Type:  pemType,
                Bytes: data,
        })

        // random nonce
        nonce := make([]byte, gcm.NonceSize())
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("generate a random nonce: %w", err)
        }</span>

        <span class="cov8" title="1">return gcm.Seal(nonce, nonce, pemData, nil), nil</span>
}

func (kp *KeyPair) decrypt(password, salt, cert, pk []byte) error <span class="cov8" title="1">{
        gcm, err := gcmCipher(salt, password)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("generate GCM cipher: %w", err)
        }</span>

        // certificate
        <span class="cov8" title="1">certPem, err := decryptPemWithGCM(gcm, cert)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("decrypt certificate: %w", err)
        }</span>

        <span class="cov8" title="1">kp.Cert, err = x509.ParseCertificate(certPem)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("parse certificate: %w", err)
        }</span>

        // private key
        <span class="cov8" title="1">pkPem, err := decryptPemWithGCM(gcm, pk)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("decrypt private key: %w", err)
        }</span>

        <span class="cov8" title="1">kp.PK, err = x509.ParsePKCS1PrivateKey(pkPem)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("parse private key: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func decryptPemWithGCM(gcm cipher.AEAD, cipherText []byte) ([]byte, error) <span class="cov8" title="1">{
        nonceSize := gcm.NonceSize()
        // nonce is part of the cipher text and therefore must be smaller
        if len(cipherText) &lt; nonceSize </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("nonce is longer than cipher text: %w", ErrInvalidDecryptionKey)
        }</span>

        // split nonce and cipher
        <span class="cov8" title="1">nonce, sealed := cipherText[:nonceSize], cipherText[nonceSize:]
        // open sealed cipher
        pemData, err := gcm.Open(nil, nonce, sealed, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, multierr.Append(fmt.Errorf("open sealed cipher text: %w", err), ErrInvalidDecryptionKey)
        }</span>

        <span class="cov8" title="1">block, _ := pem.Decode(pemData)

        return block.Bytes, nil</span>
}

func gcmCipher(salt, password []byte) (cipher.AEAD, error) <span class="cov8" title="1">{
        salted := addSalt(salt, password)
        hash := sha256.Sum256(salted)

        c, err := aes.NewCipher(hash[:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create a new cipher block: %w", err)
        }</span>

        <span class="cov8" title="1">gcm, err := cipher.NewGCM(c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create a GCM cipher mode: %w", err)
        }</span>

        <span class="cov8" title="1">return gcm, nil</span>
}

func addSalt(salt []byte, password []byte) []byte <span class="cov8" title="1">{
        lp := len(password)
        ls := len(salt)

        // concatenate password and salt
        out := make([]byte, lp+ls)
        copy(out[:lp], password)
        copy(out[lp:], salt)

        return out
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package keystore

import (
        "context"
        "crypto/rand"
        "errors"
        "fmt"
        "io"

        "github.com/go-redis/redis/v8"
)

// ErrRecordNotFound is returned if a record can't be found.
var ErrRecordNotFound = errors.New("record not found")

// ErrIDAlreadyExists is returned if an ID is already in use.
var ErrIDAlreadyExists = errors.New("record with the id already exists")

// ErrReachedMaxAttempts is returned if the maximum number of attempts of transactions is reached.
var ErrReachedMaxAttempts = errors.New("maximum number of attempts reached")

var (
        // IDsObjectKey is the redis object key for storing certificate IDs.
        IDsObjectKey = "ids"
        // CertObjectKey is the redis object key for storing certificates.
        CertObjectKey = "certificate"

        // PublicKey is the redis key of the certificate field.
        PublicKey = "public-key"
        // PrivateKeyKey is the redis key of the private key field.
        PrivateKeyKey = "private-key"
        // SaltKey is the redis key of the salt field.
        SaltKey = "salt"
)

// ToCertObjectKey converts a certificate ID to a keystore object key.
func ToCertObjectKey(id string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%s", CertObjectKey, id)
}</span>

// Service represents a keystore abstraction for KeyPair management.
type Service interface {
        Ping(ctx context.Context) error
        Store(ctx context.Context, id string, password []byte, kp *KeyPair) error
        Get(ctx context.Context, id string, password []byte) (*KeyPair, error)
        List(ctx context.Context, start, end int64) ([]string, error)
        UpdateID(ctx context.Context, oldID, newID string) error
        UpdatePassword(ctx context.Context, id string, oldPassword, newPassword []byte) error
        Delete(ctx context.Context, id string) error
}

type redisService struct {
        rdb *redis.Client
}

// Ping tries to connect to the database and find out whether it is online.
func (r *redisService) Ping(ctx context.Context) error <span class="cov8" title="1">{
        return r.rdb.Ping(ctx).Err()
}</span>

// Store stores the given KeyPair kp in the database encrypted with the password.
func (r *redisService) Store(ctx context.Context, id string, password []byte, kp *KeyPair) error <span class="cov8" title="1">{
        idx := ToCertObjectKey(id)

        // generate random salt for each record
        salt := make([]byte, 256)
        if _, err := io.ReadFull(rand.Reader, salt); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("generate a random salt value: %w", err)
        }</span>

        <span class="cov8" title="1">cert, pk, err := kp.encrypt(password, salt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("encrypt a KeyPair: %w", err)
        }</span>

        <span class="cov8" title="1">txf := func(tx *redis.Tx) error </span><span class="cov8" title="1">{
                // check if already exists
                i, err := tx.Exists(ctx, idx).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("check if certificate exists: %w", err)
                }</span>

                <span class="cov8" title="1">if i != 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("found record with same id: %w", ErrIDAlreadyExists)
                }</span>

                <span class="cov8" title="1">_, err = tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error </span><span class="cov8" title="1">{
                        // store in database
                        _, err = pipe.HSet(ctx, idx, map[string]interface{}{
                                PublicKey:     cert,
                                PrivateKeyKey: pk,
                                SaltKey:       salt,
                        }).Result()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("store certificate in database: %w", err)
                        }</span>

                        // add to the list of certificate IDs
                        <span class="cov8" title="1">_, err = pipe.RPush(ctx, IDsObjectKey, id).Result()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add id to the id list: %w", err)
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                })
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">for k := 0; k &lt; 3; k++ </span><span class="cov8" title="1">{
                err = r.rdb.Watch(ctx, txf, idx, IDsObjectKey)
                if errors.Is(err, redis.TxFailedErr) </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("transaction failed: %w", err)
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov0" title="0">return ErrReachedMaxAttempts</span>
}

// Get retrieves a KeyPair by the ID.
func (r *redisService) Get(ctx context.Context, id string, password []byte) (*KeyPair, error) <span class="cov8" title="1">{
        idx := ToCertObjectKey(id)

        m := make(map[string]string)
        txf := func(tx *redis.Tx) error </span><span class="cov8" title="1">{
                // check if exists
                i, err := tx.Exists(ctx, idx).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("check if id exists: %w", err)
                }</span>

                <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("not found record with the id: %w", ErrRecordNotFound)
                }</span>

                // read from database
                <span class="cov8" title="1">m, err = tx.HGetAll(ctx, idx).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("retrieve stored certificate from database: %w", err)
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">for k := 0; k &lt; 3; k++ </span><span class="cov8" title="1">{
                err := r.rdb.Watch(ctx, txf, idx, IDsObjectKey)
                if errors.Is(err, redis.TxFailedErr) </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("transaction failed: %w", err)
                }</span>

                <span class="cov8" title="1">salt := []byte(m[SaltKey])
                cert := []byte(m[PublicKey])
                pk := []byte(m[PrivateKeyKey])

                kp := new(KeyPair)
                err = kp.decrypt(password, salt, cert, pk)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("decrypt a KeyPair: %w", err)
                }</span>

                <span class="cov8" title="1">return kp, nil</span>
        }

        <span class="cov0" title="0">return nil, ErrReachedMaxAttempts</span>
}

// List returns all record keys in the database.
func (r *redisService) List(ctx context.Context, start, end int64) ([]string, error) <span class="cov8" title="1">{
        ids, err := r.rdb.LRange(ctx, IDsObjectKey, start, end).Result()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("read all records: %w", err)
        }</span>

        <span class="cov8" title="1">return ids, nil</span>
}

// UpdateID modifies the ID of the record.
func (r *redisService) UpdateID(ctx context.Context, oldID, newID string) error <span class="cov8" title="1">{
        oldIDx := ToCertObjectKey(oldID)
        newIDx := ToCertObjectKey(newID)

        txf := func(tx *redis.Tx) error </span><span class="cov8" title="1">{
                // check if exists
                i, err := tx.Exists(ctx, oldIDx).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("check if id exists: %w", err)
                }</span>

                <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("not found record with the id: %w", ErrRecordNotFound)
                }</span>

                // check if the new ID already exists
                <span class="cov8" title="1">i, err = tx.Exists(ctx, newIDx).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("check if new id exists: %w", err)
                }</span>

                <span class="cov8" title="1">if i != 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("found record with the new id: %w", ErrIDAlreadyExists)
                }</span>

                <span class="cov8" title="1">_, err = tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error </span><span class="cov8" title="1">{
                        // update ID
                        _, err := pipe.Rename(ctx, oldIDx, newIDx).Result()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("rename: %w", err)
                        }</span>

                        // update the ID in the list of IDs
                        <span class="cov8" title="1">_, err = pipe.LRem(ctx, IDsObjectKey, 0, oldID).Result()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("remove id from the id list: %w", err)
                        }</span>

                        <span class="cov8" title="1">_, err = pipe.RPush(ctx, IDsObjectKey, newID).Result()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add id to the id list: %w", err)
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                })
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">for k := 0; k &lt; 3; k++ </span><span class="cov8" title="1">{
                err := r.rdb.Watch(ctx, txf, oldIDx, IDsObjectKey)
                if errors.Is(err, redis.TxFailedErr) </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("transaction failed: %w", err)
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov0" title="0">return ErrReachedMaxAttempts</span>
}

// UpdatePassword modifies the password for encryption/decryption of the record.
func (r *redisService) UpdatePassword(ctx context.Context, id string, oldPassword, newPassword []byte) error <span class="cov8" title="1">{
        idx := ToCertObjectKey(id)

        txf := func(tx *redis.Tx) error </span><span class="cov8" title="1">{
                // check if exists
                i, err := tx.Exists(ctx, idx).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("check if id exists: %w", err)
                }</span>

                <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("record not found by the id: %w", ErrRecordNotFound)
                }</span>

                // read from database
                <span class="cov8" title="1">m, err := tx.HGetAll(ctx, idx).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("retrieve stored certificate from database: %w", err)
                }</span>

                // decrypt KeyPair with the old password
                <span class="cov8" title="1">salt := []byte(m[SaltKey])
                cert := []byte(m[PublicKey])
                pk := []byte(m[PrivateKeyKey])

                kp := new(KeyPair)
                err = kp.decrypt(oldPassword, salt, cert, pk)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("decrypt a KeyPair: %w", err)
                }</span>

                // encrypt KeyPair with the new password
                <span class="cov8" title="1">cert, pk, err = kp.encrypt(newPassword, salt)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("encrypt a KeyPair: %w", err)
                }</span>

                <span class="cov8" title="1">_, err = tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error </span><span class="cov8" title="1">{
                        // overwrite in database
                        _, err = pipe.HSet(ctx, idx, map[string]interface{}{
                                PublicKey:     cert,
                                PrivateKeyKey: pk,
                        }).Result()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("store certificate in database: %w", err)
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                })
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">for k := 0; k &lt; 3; k++ </span><span class="cov8" title="1">{
                err := r.rdb.Watch(ctx, txf, idx)
                if errors.Is(err, redis.TxFailedErr) </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("transaction failed: %w", err)
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov0" title="0">return ErrReachedMaxAttempts</span>
}

// Delete removes the KeyPair with the ID.
func (r *redisService) Delete(ctx context.Context, id string) error <span class="cov8" title="1">{
        idx := ToCertObjectKey(id)

        txf := func(tx *redis.Tx) error </span><span class="cov8" title="1">{
                // check if exists
                i, err := tx.Exists(ctx, idx).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("check if id exists: %w", err)
                }</span>

                <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("not found record with the id: %w", ErrRecordNotFound)
                }</span>

                <span class="cov8" title="1">_, err = tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error </span><span class="cov8" title="1">{
                        // remove
                        _, err := pipe.Del(ctx, idx).Result()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("delete record from database: %w", err)
                        }</span>

                        // update the ID in the list of IDs
                        <span class="cov8" title="1">_, err = pipe.LRem(ctx, IDsObjectKey, 0, id).Result()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("remove id from the ID list: %w", err)
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                })
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">for k := 0; k &lt; 3; k++ </span><span class="cov8" title="1">{
                err := r.rdb.Watch(ctx, txf, idx, IDsObjectKey)
                if errors.Is(err, redis.TxFailedErr) </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("transaction failed: %w", err)
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov0" title="0">return ErrReachedMaxAttempts</span>
}

// NewRedisService returns an implementation of the Service.
func NewRedisService(rdb *redis.Client) Service <span class="cov8" title="1">{
        return &amp;redisService{
                rdb: rdb,
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package httphandler

import (
        "encoding/base64"
        "net/http"

        "github.com/gin-gonic/gin"
)

func (h *Handler) storeCert(c *gin.Context) <span class="cov8" title="1">{
        req := &amp;StoreCertReq{}
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                err = bindingErr(err)
                c.JSON(http.StatusBadRequest, GatewayErrResp{err.Error()})
                _ = c.Error(err)
                return
        }</span>

        <span class="cov8" title="1">data, err := base64.StdEncoding.DecodeString(req.PKCS12Data)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, GatewayErrResp{err.Error()})
                _ = c.Error(err)
                return
        }</span>

        <span class="cov8" title="1">err = h.gateway.StoreCert(c, req.CertID, []byte(req.CertPassword), data, req.PKCS12Password)
        if err != nil </span><span class="cov8" title="1">{
                code, resp := gatewayErrResp(err)
                c.JSON(code, resp)
                _ = c.Error(err)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, successCertResp(req.CertID))</span>
}

func (h *Handler) listCertIDs(c *gin.Context) <span class="cov8" title="1">{
        // default request
        req := &amp;ListCertIDsReq{
                Offset: 0,
                Limit:  1000,
        }

        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov8" title="1">{
                err = bindingErr(err)
                c.JSON(http.StatusBadRequest, GatewayErrResp{err.Error()})
                _ = c.Error(err)
                return
        }</span>

        <span class="cov8" title="1">start, end := req.Offset, req.Offset+req.Limit-1
        if req.Limit == 0 </span><span class="cov8" title="1">{
                end = -1
        }</span>

        <span class="cov8" title="1">ids, err := h.gateway.ListCertIDs(c, start, end)
        if err != nil </span><span class="cov8" title="1">{
                code, resp := gatewayErrResp(err)
                c.JSON(code, resp)
                _ = c.Error(err)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, ListCertIDsResp{CertIDs: ids})</span>
}

func (h *Handler) updateCertID(c *gin.Context) <span class="cov8" title="1">{
        reqURI := &amp;UpdateCertIDURIReq{}
        if err := c.ShouldBindUri(&amp;reqURI); err != nil </span><span class="cov8" title="1">{
                err = bindingErr(err)
                c.JSON(http.StatusBadRequest, GatewayErrResp{err.Error()})
                _ = c.Error(err)
                return
        }</span>

        <span class="cov8" title="1">reqJSON := &amp;UpdateCertIDJSONReq{}
        if err := c.ShouldBindJSON(&amp;reqJSON); err != nil </span><span class="cov8" title="1">{
                err = bindingErr(err)
                c.JSON(http.StatusBadRequest, GatewayErrResp{err.Error()})
                _ = c.Error(err)
                return
        }</span>

        <span class="cov8" title="1">err := h.gateway.UpdateCertID(c, reqURI.CertID, reqJSON.NewID)
        if err != nil </span><span class="cov8" title="1">{
                code, resp := gatewayErrResp(err)
                c.JSON(code, resp)
                _ = c.Error(err)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, successCertResp(reqJSON.NewID))</span>
}

func (h *Handler) updateCertPassword(c *gin.Context) <span class="cov8" title="1">{
        reqURI := &amp;UpdateCertPasswordURIReq{}
        if err := c.ShouldBindUri(&amp;reqURI); err != nil </span><span class="cov8" title="1">{
                err = bindingErr(err)
                c.JSON(http.StatusBadRequest, GatewayErrResp{err.Error()})
                _ = c.Error(err)
                return
        }</span>

        <span class="cov8" title="1">reqJSON := &amp;UpdateCertPasswordJSONReq{}
        if err := c.ShouldBindJSON(&amp;reqJSON); err != nil </span><span class="cov8" title="1">{
                err = bindingErr(err)
                c.JSON(http.StatusBadRequest, GatewayErrResp{err.Error()})
                _ = c.Error(err)
                return
        }</span>

        <span class="cov8" title="1">err := h.gateway.UpdateCertPassword(c, reqURI.CertID, []byte(reqJSON.CertPassword), []byte(reqJSON.NewPassword))
        if err != nil </span><span class="cov8" title="1">{
                code, resp := gatewayErrResp(err)
                c.JSON(code, resp)
                _ = c.Error(err)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, successCertResp(reqURI.CertID))</span>
}

func (h *Handler) deleteCert(c *gin.Context) <span class="cov8" title="1">{
        req := &amp;DeleteCertReq{}
        if err := c.ShouldBindUri(&amp;req); err != nil </span><span class="cov0" title="0">{
                err = bindingErr(err)
                c.JSON(http.StatusBadRequest, GatewayErrResp{err.Error()})
                _ = c.Error(err)
                return
        }</span>

        <span class="cov8" title="1">err := h.gateway.DeleteID(c, req.CertID)
        if err != nil </span><span class="cov8" title="1">{
                code, resp := gatewayErrResp(err)
                c.JSON(code, resp)
                _ = c.Error(err)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, successCertResp(req.CertID))</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package httphandler

import (
        "errors"
        "fmt"
        "net/http"

        "github.com/chutommy/eetgateway/pkg/gateway"
        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
)

// ErrUnexpected is returned if unexpected error is raised.
var ErrUnexpected = errors.New("unexpected error")

// Handler is HTTP requests handler.
type Handler struct {
        gateway gateway.Service
}

// NewHandler returns an implementation of Handler.
func NewHandler(g gateway.Service) *Handler <span class="cov8" title="1">{
        return &amp;Handler{
                gateway: g,
        }
}</span>

// HTTPHandler implements server.Handler.
func (h *Handler) HTTPHandler() http.Handler <span class="cov8" title="1">{
        gin.SetMode(gin.ReleaseMode)

        r := gin.New()

        setValidators()
        r.Use(loggingMiddleware)
        r.Use(recoverMiddleware)

        v1 := r.Group("/v1")
        </span><span class="cov8" title="1">{
                v1.GET("/ping", h.ping)
                v1.POST("/sale", h.sendSale)
                v1.POST("/certs", h.storeCert)
                v1.GET("/certs", h.listCertIDs)
                v1.PUT("/certs/:cert_id/id", h.updateCertID)
                v1.PUT("/certs/:cert_id/password", h.updateCertPassword)
                v1.DELETE("/certs/:cert_id", h.deleteCert)
        }</span>

        <span class="cov8" title="1">return r</span>
}

func bindingErr(err error) error <span class="cov8" title="1">{
        var verr validator.ValidationErrors
        if errors.As(err, &amp;verr) </span><span class="cov8" title="1">{
                err = errors.New("invalid request body")
                for _, f := range verr </span><span class="cov8" title="1">{
                        if p := f.Param(); p == "" </span><span class="cov8" title="1">{
                                err = fmt.Errorf("%w %s=%s", err, f.Field(), f.Tag())
                        }</span> else<span class="cov8" title="1"> {
                                err = fmt.Errorf("%w %s=%s(%s)", err, f.Field(), f.Tag(), p)
                        }</span>
                }
        }

        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package httphandler

import (
        "errors"

        "github.com/chutommy/eetgateway/pkg/gateway"
        "github.com/gin-gonic/gin"
)

func (h *Handler) ping(c *gin.Context) <span class="cov8" title="1">{
        err := h.gateway.Ping(c)
        var taxAdmin error
        if errors.Is(err, gateway.ErrFSCRConnection) </span><span class="cov8" title="1">{
                taxAdmin = gateway.ErrFSCRConnection
                _ = c.Error(gateway.ErrFSCRConnection)
        }</span>

        <span class="cov8" title="1">var keyStore error
        if errors.Is(err, gateway.ErrKeystoreUnavailable) </span><span class="cov8" title="1">{
                keyStore = gateway.ErrKeystoreUnavailable
                _ = c.Error(gateway.ErrKeystoreUnavailable)
        }</span>

        <span class="cov8" title="1">code, resp := pingEETResp(taxAdmin, keyStore)
        c.JSON(code, resp)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package httphandler

import (
        "errors"
        "net"
        "net/http"
        "os"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/rs/zerolog/log"
)

func loggingMiddleware(c *gin.Context) <span class="cov8" title="1">{
        start := time.Now()

        c.Next()

        log.Info().
                Str("entity", "HTTP Handler").
                Str("action", "serving request").
                Str("client", c.ClientIP()).
                Str("method", c.Request.Method).
                Str("path", c.Request.URL.Path).
                Int64("requestBodySize", c.Request.ContentLength).
                Int("responseBodySize", c.Writer.Size()).
                Int("status", c.Writer.Status()).
                TimeDiff("latency", time.Now(), start).
                Err(c.Errors.Last()).
                Send()
}</span>

func recoverMiddleware(c *gin.Context) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        // Check for a broken connection, as it is not really a condition that warrants a panic stack trace.
                        var brokenPipe bool
                        if ne, ok := err.(*net.OpError); ok </span><span class="cov0" title="0">{
                                var se *os.SyscallError
                                if ok := errors.Is(ne.Err, se); ok </span><span class="cov0" title="0">{
                                        if strings.Contains(strings.ToLower(se.Error()), "broken pipe") || strings.Contains(strings.ToLower(se.Error()), "connection reset by peer") </span><span class="cov0" title="0">{
                                                brokenPipe = true
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">log.Error().
                                Str("entity", "Recovery system").
                                Str("action", "recovering from fatal error").
                                Err(err.(error)).
                                Send()

                        if brokenPipe </span><span class="cov0" title="0">{
                                // If the connection is dead, we can't write a status to it.
                                c.Abort()
                                return
                        }</span>

                        <span class="cov0" title="0">c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"fatal_error": ErrUnexpected.Error()})</span>
                }
        }()

        <span class="cov8" title="1">c.Next()</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package httphandler

import (
        "errors"
        "net/http"

        "github.com/chutommy/eetgateway/pkg/eet"
        "github.com/chutommy/eetgateway/pkg/gateway"
)

// PingEETResp is a response structure for HTTP pings.
type PingEETResp struct {
        EETGatewayStatus string `json:"eet_gateway"`
        TaxAdminStatus   string `json:"tax_admin"`
        KeystoreStatus   string `json:"keystore"`
}

func pingEETResp(taxAdmin error, keyStore error) (int, *PingEETResp) <span class="cov8" title="1">{
        online := func(err error) string </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        return err.Error()
                }</span>

                <span class="cov8" title="1">return "online"</span>
        }

        <span class="cov8" title="1">code := http.StatusOK
        if taxAdmin != nil || keyStore != nil </span><span class="cov8" title="1">{
                code = http.StatusServiceUnavailable
        }</span>

        <span class="cov8" title="1">return code, &amp;PingEETResp{
                EETGatewayStatus: "online", // is able to response
                TaxAdminStatus:   online(taxAdmin),
                KeystoreStatus:   online(keyStore),
        }</span>
}

// SendSaleReq is a binding request structure for sales.
type SendSaleReq struct {
        CertID       string `json:"cert_id,omitempty" binding:"required"`
        CertPassword string `json:"cert_password,omitempty" binding:"required"`

        UUIDZpravy      eet.UUIDType   `json:"uuid_zpravy" binding:"omitempty,uuid_zpravy"`
        DatOdesl        *eet.DateTime  `json:"dat_odesl,omitempty" binding:""`
        PrvniZaslani    bool           `json:"prvni_zaslani" binding:""`
        Overeni         bool           `json:"overeni" binding:""`
        DICPopl         eet.CZDICType  `json:"dic_popl" binding:"required,dic"`
        DICPoverujiciho eet.CZDICType  `json:"dic_poverujiciho" binding:"omitempty,dic,necsfield=Dicpopl"`
        IDProvoz        int            `json:"id_provoz" binding:"required,id_provoz"`
        IDPokl          eet.String20   `json:"id_pokl" binding:"required,id_pokl"`
        PoradCis        eet.String25   `json:"porad_cis" binding:"required,porad_cis"`
        DatTrzby        *eet.DateTime  `json:"dat_trzby,omitempty" binding:"required"`
        CelkTrzba       eet.CastkaType `json:"celk_trzba" binding:"required,fin_poloz"`
        ZaklNepodlDPH   eet.CastkaType `json:"zakl_nepodl_dph" binding:"omitempty,fin_poloz"`
        ZaklDan1        eet.CastkaType `json:"zakl_dan1" binding:"omitempty,fin_poloz"`
        Dan1            eet.CastkaType `json:"dan1" binding:"omitempty,fin_poloz"`
        ZaklDan2        eet.CastkaType `json:"zakl_dan2" binding:"omitempty,fin_poloz"`
        Dan2            eet.CastkaType `json:"dan2" binding:"omitempty,fin_poloz"`
        ZaklDan3        eet.CastkaType `json:"zakl_dan3" binding:"omitempty,fin_poloz"`
        Dan3            eet.CastkaType `json:"dan3" binding:"omitempty,fin_poloz"`
        CestSluz        eet.CastkaType `json:"cest_sluz" binding:"omitempty,fin_poloz"`
        PouzitZboz1     eet.CastkaType `json:"pouzit_zboz1" binding:"omitempty,fin_poloz"`
        PouzitZboz2     eet.CastkaType `json:"pouzit_zboz2" binding:"omitempty,fin_poloz"`
        PouzitZboz3     eet.CastkaType `json:"pouzit_zboz3" binding:"omitempty,fin_poloz"`
        UrcenoCerpzZuct eet.CastkaType `json:"urceno_cerp_zuct" binding:"omitempty,fin_poloz"`
        CerpZuct        eet.CastkaType `json:"cerp_zuct" binding:"omitempty,fin_poloz"`
        Rezim           eet.RezimType  `json:"rezim" binding:"omitempty,rezim"`
}

func sendSaleRequest(req *SendSaleReq) *eet.TrzbaType <span class="cov8" title="1">{
        return &amp;eet.TrzbaType{
                Hlavicka: eet.TrzbaHlavickaType{
                        Uuidzpravy:   req.UUIDZpravy,
                        Datodesl:     *req.DatOdesl,
                        Prvnizaslani: req.PrvniZaslani,
                        Overeni:      req.Overeni,
                },
                Data: eet.TrzbaDataType{
                        Dicpopl:         req.DICPopl,
                        Dicpoverujiciho: req.DICPoverujiciho,
                        Idprovoz:        req.IDProvoz,
                        Idpokl:          req.IDPokl,
                        Poradcis:        req.PoradCis,
                        Dattrzby:        *req.DatTrzby,
                        Celktrzba:       req.CelkTrzba,
                        Zaklnepodldph:   req.ZaklNepodlDPH,
                        Zakldan1:        req.ZaklDan1,
                        Dan1:            req.Dan1,
                        Zakldan2:        req.ZaklDan2,
                        Dan2:            req.Dan2,
                        Zakldan3:        req.ZaklDan3,
                        Dan3:            req.Dan3,
                        Cestsluz:        req.CestSluz,
                        Pouzitzboz1:     req.PouzitZboz1,
                        Pouzitzboz2:     req.PouzitZboz2,
                        Pouzitzboz3:     req.PouzitZboz3,
                        Urcenocerpzuct:  req.UrcenoCerpzZuct,
                        Cerpzuct:        req.CerpZuct,
                        Rezim:           req.Rezim,
                },
        }
}</span>

// SendSaleResp is a reponse structure to sale requests.
type SendSaleResp struct {
        CertID string `json:"cert_id"`

        DatOdmit   *eet.DateTime `json:"dat_odmit,omitempty"`
        ChybZprava string        `json:"chyb_zprava,omitempty"`
        ChybKod    int           `json:"chyb_kod,omitempty"`

        DatPrij *eet.DateTime `json:"dat_prij,omitempty"`
        FIK     eet.FikType   `json:"fik,omitempty"`
        BKP     string        `json:"bkp,omitempty"`

        Test     bool                      `json:"test,omitempty"`
        Varovani []eet.OdpovedVarovaniType `json:"varovani,omitempty"`

        Trzba *SendSaleReq `json:"trzba,omitempty"`
}

func sendSaleResponse(req *SendSaleReq, odpoved *eet.OdpovedType) *SendSaleResp <span class="cov8" title="1">{
        certID := req.CertID
        req.CertID, req.CertPassword = "", ""

        if (odpoved.Hlavicka.Datodmit != eet.DateTime{}) </span><span class="cov0" title="0">{
                return &amp;SendSaleResp{
                        CertID:     certID,
                        DatOdmit:   &amp;odpoved.Hlavicka.Datodmit,
                        ChybZprava: odpoved.Chyba.Zprava,
                        ChybKod:    odpoved.Chyba.Kod,
                        Test:       odpoved.Potvrzeni.Test || odpoved.Chyba.Test,
                        Varovani:   odpoved.Varovani,
                }
        }</span>

        <span class="cov8" title="1">return &amp;SendSaleResp{
                CertID:   certID,
                DatPrij:  &amp;odpoved.Hlavicka.Datprij,
                FIK:      odpoved.Potvrzeni.Fik,
                BKP:      string(odpoved.Hlavicka.Bkp),
                Test:     odpoved.Potvrzeni.Test,
                Varovani: odpoved.Varovani,

                Trzba: req,
        }</span>
}

// StoreCertReq is a binding request structure for storing certificates.
type StoreCertReq struct {
        CertID         string `json:"cert_id" binding:"required"`
        CertPassword   string `json:"cert_password" binding:"required"`
        PKCS12Data     string `json:"pkcs12_data" binding:"required,base64"`
        PKCS12Password string `json:"pkcs12_password" binding:"required"`
}

// ListCertIDsReq is a binding request structure for listing certificate IDs.
type ListCertIDsReq struct {
        Offset int64 `form:"offset" binding:"gte=0"`
        Limit  int64 `form:"limit" binding:"gte=0"`
}

// ListCertIDsResp is a response structure for listing certificate IDs.
type ListCertIDsResp struct {
        CertIDs []string `json:"cert_ids"`
}

// UpdateCertIDURIReq is a URI binding request structure for certificate ID updates.
type UpdateCertIDURIReq struct {
        CertID string `uri:"cert_id" binding:"required"`
}

// UpdateCertIDJSONReq is a JSON binding request structure for certificate ID updates.
type UpdateCertIDJSONReq struct {
        NewID string `json:"new_id" binding:"required"`
}

// UpdateCertPasswordURIReq is a URI binding request structure for password updates.
type UpdateCertPasswordURIReq struct {
        CertID string `uri:"cert_id" binding:"required"`
}

// UpdateCertPasswordJSONReq is a JSON binding request structure for password updates.
type UpdateCertPasswordJSONReq struct {
        CertPassword string `json:"cert_password" binding:"required"`
        NewPassword  string `json:"new_password" binding:"required,necsfield=CertPassword"`
}

// DeleteCertReq is a binding request structure for deleting certificates.
type DeleteCertReq struct {
        CertID string `uri:"cert_id" binding:"required"`
}

// SuccessCertResp is a response of a successful action related to certificate.
type SuccessCertResp struct {
        CertID string `json:"cert_id" example:"d406ccda-1bc5-44ab-a081-af6e8740634c"`
} //@name SuccessResponse

func successCertResp(id string) *SuccessCertResp <span class="cov8" title="1">{
        return &amp;SuccessCertResp{CertID: id}
}</span>

// GatewayErrResp represents an error response structure returned from the EET Gateway API (not from the FSCR).
type GatewayErrResp struct {
        GatewayError string `json:"gateway_error" example:"keystore service unavailable"`
} //@name GatewayErrorResponse

func gatewayErrResp(err error) (int, *GatewayErrResp) <span class="cov8" title="1">{
        c, e := http.StatusInternalServerError, ErrUnexpected

        switch </span>{
        case errors.Is(err, gateway.ErrCertificateNotFound):<span class="cov0" title="0">
                c, e = http.StatusNotFound, gateway.ErrCertificateNotFound</span>
        case errors.Is(err, gateway.ErrInvalidCertificatePassword):<span class="cov8" title="1">
                c, e = http.StatusUnauthorized, gateway.ErrInvalidCertificatePassword</span>
        case errors.Is(err, gateway.ErrIDAlreadyExists):<span class="cov0" title="0">
                c, e = http.StatusConflict, gateway.ErrIDAlreadyExists</span>
        case errors.Is(err, gateway.ErrInvalidTaxpayersCertificate):<span class="cov0" title="0">
                c, e = http.StatusBadRequest, gateway.ErrInvalidTaxpayersCertificate</span>
        case errors.Is(err, gateway.ErrFSCRConnection):<span class="cov0" title="0">
                c, e = http.StatusServiceUnavailable, gateway.ErrFSCRConnection</span>
        case errors.Is(err, gateway.ErrKeystoreUnavailable):<span class="cov8" title="1">
                c, e = http.StatusServiceUnavailable, gateway.ErrKeystoreUnavailable</span>
        case errors.Is(err, gateway.ErrRequestBuild):<span class="cov0" title="0">
                c, e = http.StatusInternalServerError, gateway.ErrRequestBuild</span>
        case errors.Is(err, gateway.ErrFSCRResponseParse):<span class="cov0" title="0">
                c, e = http.StatusInternalServerError, gateway.ErrFSCRResponseParse</span>
        case errors.Is(err, gateway.ErrFSCRResponseVerify):<span class="cov0" title="0">
                c, e = http.StatusInternalServerError, gateway.ErrFSCRResponseVerify</span>
        case errors.Is(err, gateway.ErrCertificateParse):<span class="cov0" title="0">
                c, e = http.StatusInternalServerError, gateway.ErrCertificateParse</span>
        case errors.Is(err, gateway.ErrKeystoreUnexpected):<span class="cov0" title="0">
                c, e = http.StatusInternalServerError, gateway.ErrKeystoreUnexpected</span>
        case errors.Is(err, gateway.ErrMaxTXAttempts):<span class="cov0" title="0">
                c, e = http.StatusInternalServerError, gateway.ErrMaxTXAttempts</span>
        }

        <span class="cov8" title="1">return c, &amp;GatewayErrResp{GatewayError: e.Error()}</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package httphandler

import (
        "net/http"
        "time"

        "github.com/chutommy/eetgateway/pkg/eet"
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

func (h *Handler) sendSale(c *gin.Context) <span class="cov8" title="1">{
        // default request
        dateTime := eet.DateTime(time.Now())
        dateTime.Normalize()
        req := &amp;SendSaleReq{
                UUIDZpravy:   eet.UUIDType(uuid.New().String()),
                DatOdesl:     &amp;dateTime,
                PrvniZaslani: true,
                Overeni:      false,
                Rezim:        0,
        }

        // bind to default
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                err = bindingErr(err)
                c.JSON(http.StatusBadRequest, GatewayErrResp{err.Error()})
                _ = c.Error(err)
                return
        }</span>

        <span class="cov8" title="1">req.DatOdesl.Normalize()
        req.DatTrzby.Normalize()

        odpoved, err := h.gateway.SendSale(c, req.CertID, []byte(req.CertPassword), sendSaleRequest(req))
        if err != nil </span><span class="cov8" title="1">{
                code, resp := gatewayErrResp(err)
                c.JSON(code, resp)
                _ = c.Error(err)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, sendSaleResponse(req, odpoved))</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package httphandler

import (
        "regexp"

        "github.com/gin-gonic/gin/binding"
        "github.com/go-playground/validator/v10"
)

func must(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func setValidators() <span class="cov8" title="1">{
        if v, ok := binding.Validator.Engine().(*validator.Validate); ok </span><span class="cov8" title="1">{
                must(v.RegisterValidation("uuid_zpravy", uuidZpravyValidator))
                must(v.RegisterValidation("dic", dicValidator))
                must(v.RegisterValidation("id_provoz", idProvozValidator))
                must(v.RegisterValidation("id_pokl", idPoklValidator))
                must(v.RegisterValidation("porad_cis", poradCisValidator))
                must(v.RegisterValidation("fin_poloz", finPolozValidator))
                must(v.RegisterValidation("rezim", rezimValidator))
        }</span>
}

func uuidZpravyValidator(fl validator.FieldLevel) bool <span class="cov8" title="1">{
        s := fl.Field().String()
        return match("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fAF]{3}-[0-9a-fA-F]{12}$", s)
}</span>

func dicValidator(fl validator.FieldLevel) bool <span class="cov8" title="1">{
        s := fl.Field().String()
        return match("^CZ[0-9]{8,10}$", s)
}</span>

func idProvozValidator(fl validator.FieldLevel) bool <span class="cov8" title="1">{
        i := fl.Field().Int()
        if i &lt; 1 || i &gt; 999999 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

func idPoklValidator(fl validator.FieldLevel) bool <span class="cov8" title="1">{
        s := fl.Field().String()
        return match("^[0-9a-zA-Z\\.,:;/#\\-_ ]{1,20}$", s)
}</span>

func poradCisValidator(fl validator.FieldLevel) bool <span class="cov8" title="1">{
        s := fl.Field().String()
        return match("^[0-9a-zA-Z\\.,:;/#\\-_ ]{1,25}$", s)
}</span>

func finPolozValidator(fl validator.FieldLevel) bool <span class="cov8" title="1">{
        f := fl.Field().Float()
        if f &gt;= 0 </span><span class="cov8" title="1">{
                // positive
                if f &gt; 99999999.99 </span><span class="cov0" title="0">{
                        return false
                }</span>
        } else<span class="cov0" title="0"> {
                // negative
                if f &gt; -0.01 || f &lt; -99999999.99 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func rezimValidator(fl validator.FieldLevel) bool <span class="cov8" title="1">{
        i := fl.Field().Int()
        if i != 0 &amp;&amp; i != 1 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

func match(pattern, s string) bool <span class="cov8" title="1">{
        ok, err := regexp.MatchString(pattern, s)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return ok</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package wsse

import (
        "fmt"
        "sort"

        "github.com/beevik/etree"
)

const (
        emptyPrefix = ""
        xmlnsPrefix = "xmlns"
)

func excC14NCanonicalize(elem *etree.Element) ([]byte, error) <span class="cov8" title="1">{
        if err := transformExcC14n(elem); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("transform the element (excC14N): %w", err)
        }</span>

        <span class="cov8" title="1">doc := etree.NewDocument()
        doc.SetRoot(elem.Copy())
        doc.WriteSettings = etree.WriteSettings{
                CanonicalAttrVal: true,
                CanonicalEndTags: true,
                CanonicalText:    true,
        }

        canonical, err := doc.WriteToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("write etree document to bytes: %w", err)
        }</span>

        <span class="cov8" title="1">return canonical, nil</span>
}

func transformExcC14n(el *etree.Element) error <span class="cov8" title="1">{
        err := toExcC14n(nsContext{}, nsContext{}, el)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("c14n: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func toExcC14n(ctx, declared nsContext, el *etree.Element) error <span class="cov8" title="1">{
        scope, err := ctx.subContext(el)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create subcontext: %w", err)
        }</span>

        <span class="cov8" title="1">utilizedPrefixes := map[string]struct{}{
                el.Space: {},
        }

        var filteredAttrs []etree.Attr
        for _, attr := range el.Attr </span><span class="cov8" title="1">{
                if attr.Space != xmlnsPrefix &amp;&amp; (attr.Space != emptyPrefix || attr.Key != xmlnsPrefix) </span><span class="cov8" title="1">{
                        if attr.Space != emptyPrefix </span><span class="cov8" title="1">{
                                utilizedPrefixes[attr.Space] = struct{}{}
                        }</span>

                        <span class="cov8" title="1">filteredAttrs = append(filteredAttrs, attr)</span>
                }
        }

        <span class="cov8" title="1">el.Attr = filteredAttrs
        declared = declared.copy()

        for prefix := range utilizedPrefixes </span><span class="cov8" title="1">{
                if declaredNamespace, ok := declared.prefixes[prefix]; ok </span><span class="cov8" title="1">{
                        value, ok := scope.prefixes[prefix]
                        if ok &amp;&amp; declaredNamespace == value </span><span class="cov8" title="1">{
                                continue</span>
                        }
                }

                <span class="cov8" title="1">ns := scope.prefixes[prefix]
                el.Attr = append(el.Attr, declared.declare(prefix, ns))</span>
        }

        <span class="cov8" title="1">sort.Sort(sortableAttrs(el.Attr))

        for _, child := range el.ChildElements() </span><span class="cov8" title="1">{
                err := toExcC14n(scope, declared, child)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("canonicalize %s to exc c14n: %w", child.FullTag(), err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

type nsContext struct {
        prefixes map[string]string
}

func (ctx nsContext) subContext(el *etree.Element) (nsContext, error) <span class="cov8" title="1">{
        nCtx := ctx.copy()

        for _, attr := range el.Attr </span><span class="cov8" title="1">{
                if attr.Space == xmlnsPrefix </span><span class="cov8" title="1">{
                        nCtx.declare(attr.Key, attr.Value)
                }</span> else<span class="cov8" title="1"> if attr.Space == emptyPrefix &amp;&amp; attr.Key == xmlnsPrefix </span><span class="cov8" title="1">{
                        nCtx.declare(emptyPrefix, attr.Value)
                }</span>
        }

        <span class="cov8" title="1">return nCtx, nil</span>
}

func (ctx nsContext) copy() nsContext <span class="cov8" title="1">{
        prefixes := make(map[string]string, len(ctx.prefixes)+4)
        for k, v := range ctx.prefixes </span><span class="cov8" title="1">{
                prefixes[k] = v
        }</span>

        <span class="cov8" title="1">return nsContext{prefixes}</span>
}

func (ctx nsContext) declare(prefix, ns string) etree.Attr <span class="cov8" title="1">{
        ctx.prefixes[prefix] = ns

        if prefix == emptyPrefix </span><span class="cov8" title="1">{
                return etree.Attr{
                        Key:   xmlnsPrefix,
                        Value: ns,
                }
        }</span>

        <span class="cov8" title="1">return etree.Attr{
                Space: xmlnsPrefix,
                Key:   prefix,
                Value: ns,
        }</span>
}

type sortableAttrs []etree.Attr

func (a sortableAttrs) Len() int <span class="cov8" title="1">{
        return len(a)
}</span>

func (a sortableAttrs) Swap(i, j int) <span class="cov8" title="1">{
        a[i], a[j] = a[j], a[i]
}</span>

func (a sortableAttrs) Less(i, j int) bool <span class="cov8" title="1">{
        switch </span>{
        case a[j].Space == emptyPrefix &amp;&amp; a[j].Key == xmlnsPrefix:<span class="cov0" title="0">
                return false</span>

        case a[i].Space == emptyPrefix &amp;&amp; a[i].Key == xmlnsPrefix:<span class="cov0" title="0">
                return true</span>

        case a[i].Space == xmlnsPrefix:<span class="cov8" title="1">
                if a[j].Space == xmlnsPrefix </span><span class="cov8" title="1">{
                        return a[i].Key &lt; a[j].Key
                }</span>

                <span class="cov8" title="1">return true</span>

        case a[j].Space == xmlnsPrefix:<span class="cov0" title="0">
                return false</span>

        case a[i].Space == emptyPrefix:<span class="cov8" title="1">
                if a[j].Space == emptyPrefix </span><span class="cov8" title="1">{
                        return a[i].Key &lt; a[j].Key
                }</span>

                <span class="cov0" title="0">return true</span>

        case a[j].Space == emptyPrefix:<span class="cov0" title="0">
                return false</span>
        }

        <span class="cov0" title="0">return a[i].Space &lt; a[j].Space</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package wsse

import (
        "crypto"
        "crypto/rand"
        "crypto/rsa"
        "fmt"

        "github.com/beevik/etree"
)

// CalcSignature calculates a signature value of the signedInfo element.
func CalcSignature(pk *rsa.PrivateKey, signedInfo *etree.Element) ([]byte, error) <span class="cov8" title="1">{
        signedInfo.CreateAttr("xmlns", "http://www.w3.org/2000/09/xmldsig#")
        digest, err := CalcDigest(signedInfo.Copy())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("calculate digest of signed info: %w", err)
        }</span>

        <span class="cov8" title="1">rawSig, err := rsa.SignPKCS1v15(rand.Reader, pk, crypto.SHA256, digest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("signing signedInfo digest: %w", err)
        }</span>

        <span class="cov8" title="1">return rawSig, nil</span>
}

// CalcDigest calculates a digest value of the given element.
func CalcDigest(e *etree.Element) ([]byte, error) <span class="cov8" title="1">{
        // canonical, err := dsig.MakeC14N10ExclusiveCanonicalizerWithPrefixList("").Canonicalize(e.Copy())
        // note: The line above is using the package dsig (https://github.com/russellhaering/goxmldsig) to canonicalize
        //       the etree element. The custom excC14NCanonicalize function is used instead for the performance
        //       boost (about 40% faster). Nevertheless, since the custom canonicalizer is heavily inspired by the one
        //       derived from the dsig package, the link to the original code is left for debugging purposes.
        canonical, err := excC14NCanonicalize(e.Copy())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("canonicalize the element (c14n): %w", err)
        }</span>

        <span class="cov8" title="1">hash := crypto.SHA256.New()
        _, err = hash.Write(canonical)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("hash canonicalized element: %w", err)
        }</span>

        <span class="cov8" title="1">return hash.Sum(nil), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
