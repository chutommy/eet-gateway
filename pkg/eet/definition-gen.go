// Code generated by wsdlgen. DO NOT EDIT.

// Package eet
//
package eet

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"time"
)

// May be one of SHA1
type BkpDigestType string

type BkpElementType struct {
	BkpType  BkpType         `xml:",chardata"`
	Digest   BkpDigestType   `xml:"digest,attr"`
	Encoding BkpEncodingType `xml:"encoding,attr"`
}

// May be one of base16
type BkpEncodingType string

// Must match the pattern [0-9a-fA-F]{8}-[0-9a-fA-F]{8}-[0-9a-fA-F]{8}-[0-9a-fA-F]{8}-[0-9a-fA-F]{8}
type BkpType string

// Must match the pattern CZ[0-9]{8,10}
type CZDICType string

// Must match the pattern ((0|-?[1-9]\d{0,7})\.\d\d|-0\.(0[1-9]|[1-9]\d))
type CastkaType float64

type DateTime time.Time

func (t *DateTime) UnmarshalText(text []byte) error {
	return (*xsdDateTime)(t).UnmarshalText(text)
}
func (t DateTime) MarshalText() ([]byte, error) {
	return xsdDateTime(t).MarshalText()
}

// Must match the pattern [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}-[0-9a-fA-F]{2}
type FikType string

type OdpovedChybaType struct {
	Kod  int  `xml:"kod,attr"`
	Test bool `xml:"test,attr,omitempty"`
}

type OdpovedHlavickaType struct {
	Uuidzpravy UUIDType `xml:"uuid_zpravy,attr,omitempty"`
	Bkp        BkpType  `xml:"bkp,attr,omitempty"`
	Datprij    DateTime `xml:"dat_prij,attr,omitempty"`
	Datodmit   DateTime `xml:"dat_odmit,attr,omitempty"`
}

type OdpovedPotvrzeniType struct {
	Fik  FikType `xml:"fik,attr"`
	Test bool    `xml:"test,attr,omitempty"`
}

type OdpovedType struct {
	Hlavicka  OdpovedHlavickaType   `xml:"http://fs.mfcr.cz/eet/schema/v3 Hlavicka"`
	Potvrzeni OdpovedPotvrzeniType  `xml:"http://fs.mfcr.cz/eet/schema/v3 Potvrzeni,omitempty"`
	Chyba     OdpovedChybaType      `xml:"http://fs.mfcr.cz/eet/schema/v3 Chyba,omitempty"`
	Varovani  []OdpovedVarovaniType `xml:"http://fs.mfcr.cz/eet/schema/v3 Varovani,omitempty"`
}

type OdpovedVarovaniType struct {
	Kodvarov int `xml:"kod_varov,attr"`
}

// May be one of RSA2048
type PkpCipherType string

// May be one of SHA256
type PkpDigestType string

type PkpElementType struct {
	PkpType  PkpType         `xml:",chardata"`
	Digest   PkpDigestType   `xml:"digest,attr"`
	Cipher   PkpCipherType   `xml:"cipher,attr"`
	Encoding PkpEncodingType `xml:"encoding,attr"`
}

// May be one of base64
type PkpEncodingType string

type PkpType []byte

func (t *PkpType) UnmarshalText(text []byte) error {
	return (*xsdBase64Binary)(t).UnmarshalText(text)
}
func (t PkpType) MarshalText() ([]byte, error) {
	return xsdBase64Binary(t).MarshalText()
}

// May be one of 0, 1
type RezimType int

// Must match the pattern [0-9a-zA-Z\.,:;/#\-_ ]{1,20}
type String20 string

// Must match the pattern [0-9a-zA-Z\.,:;/#\-_ ]{1,25}
type String25 string

type TrzbaDataType struct {
	Dicpopl         CZDICType  `xml:"dic_popl,attr"`
	Dicpoverujiciho CZDICType  `xml:"dic_poverujiciho,attr,omitempty"`
	Idprovoz        int        `xml:"id_provoz,attr"`
	Idpokl          String20   `xml:"id_pokl,attr"`
	Poradcis        String25   `xml:"porad_cis,attr"`
	Dattrzby        DateTime   `xml:"dat_trzby,attr"`
	Celktrzba       CastkaType `xml:"celk_trzba,attr"`
	Zaklnepodldph   CastkaType `xml:"zakl_nepodl_dph,attr,omitempty"`
	Zakldan1        CastkaType `xml:"zakl_dan1,attr,omitempty"`
	Dan1            CastkaType `xml:"dan1,attr,omitempty"`
	Zakldan2        CastkaType `xml:"zakl_dan2,attr,omitempty"`
	Dan2            CastkaType `xml:"dan2,attr,omitempty"`
	Zakldan3        CastkaType `xml:"zakl_dan3,attr,omitempty"`
	Dan3            CastkaType `xml:"dan3,attr,omitempty"`
	Cestsluz        CastkaType `xml:"cest_sluz,attr,omitempty"`
	Pouzitzboz1     CastkaType `xml:"pouzit_zboz1,attr,omitempty"`
	Pouzitzboz2     CastkaType `xml:"pouzit_zboz2,attr,omitempty"`
	Pouzitzboz3     CastkaType `xml:"pouzit_zboz3,attr,omitempty"`
	Urcenocerpzuct  CastkaType `xml:"urceno_cerp_zuct,attr,omitempty"`
	Cerpzuct        CastkaType `xml:"cerp_zuct,attr,omitempty"`
	Rezim           RezimType  `xml:"rezim,attr"`
}

type TrzbaHlavickaType struct {
	Uuidzpravy   UUIDType `xml:"uuid_zpravy,attr"`
	Datodesl     DateTime `xml:"dat_odesl,attr"`
	Prvnizaslani bool     `xml:"prvni_zaslani,attr"`
	Overeni      bool     `xml:"overeni,attr,omitempty"`
}

type TrzbaKontrolniKodyType struct {
	Pkp PkpElementType `xml:"http://fs.mfcr.cz/eet/schema/v3 pkp"`
	Bkp BkpElementType `xml:"http://fs.mfcr.cz/eet/schema/v3 bkp"`
}

type TrzbaType struct {
	Hlavicka      TrzbaHlavickaType      `xml:"http://fs.mfcr.cz/eet/schema/v3 Hlavicka"`
	Data          TrzbaDataType          `xml:"http://fs.mfcr.cz/eet/schema/v3 Data"`
	KontrolniKody TrzbaKontrolniKodyType `xml:"http://fs.mfcr.cz/eet/schema/v3 KontrolniKody"`
}

// Must match the pattern [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}
type UUIDType string

type xsdBase64Binary []byte

func (b *xsdBase64Binary) UnmarshalText(text []byte) (err error) {
	*b, err = base64.StdEncoding.DecodeString(string(text))
	return
}
func (b xsdBase64Binary) MarshalText() ([]byte, error) {
	var buf bytes.Buffer
	enc := base64.NewEncoder(base64.StdEncoding, &buf)
	enc.Write([]byte(b))
	enc.Close()
	return buf.Bytes(), nil
}

type xsdDateTime time.Time

func (t *xsdDateTime) UnmarshalText(text []byte) error {
	return _unmarshalTime(text, (*time.Time)(t), "2006-01-02T15:04:05.999999999")
}
func (t xsdDateTime) MarshalText() ([]byte, error) {
	return _marshalTime((time.Time)(t), "2006-01-02T15:04:05.999999999")
}
func (t xsdDateTime) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if (time.Time)(t).IsZero() {
		return nil
	}
	m, err := t.MarshalText()
	if err != nil {
		return err
	}
	return e.EncodeElement(m, start)
}
func (t xsdDateTime) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	if (time.Time)(t).IsZero() {
		return xml.Attr{}, nil
	}
	m, err := t.MarshalText()
	return xml.Attr{Name: name, Value: string(m)}, err
}
func _unmarshalTime(text []byte, t *time.Time, format string) (err error) {
	s := string(bytes.TrimSpace(text))
	*t, err = time.Parse(format, s)
	if _, ok := err.(*time.ParseError); ok {
		*t, err = time.Parse(format+"Z07:00", s)
	}
	return err
}
func _marshalTime(t time.Time, format string) ([]byte, error) {
	return []byte(t.Format(format + "Z07:00")), nil
}

type Client struct {
	HTTPClient   *http.Client
	ResponseHook func(*http.Response) *http.Response
	RequestHook  func(*http.Request) *http.Request
}
type soapEnvelope struct {
	XMLName struct{} `xml:"http://schemas.xmlsoap.org/soap/envelope/ Envelope"`
	Header  []byte   `xml:"http://schemas.xmlsoap.org/soap/envelope/ Header"`
	Body    struct {
		Message interface{}
		Fault   *struct {
			String string `xml:"faultstring,omitempty"`
			Code   string `xml:"faultcode,omitempty"`
			Detail string `xml:"detail,omitempty"`
		} `xml:"http://schemas.xmlsoap.org/soap/envelope/ Fault,omitempty"`
	} `xml:"http://schemas.xmlsoap.org/soap/envelope/ Body"`
}

func (c *Client) do(ctx context.Context, method, uri, action string, in, out interface{}) error {
	var body io.Reader
	var envelope soapEnvelope
	if method == "POST" || method == "PUT" {
		var buf bytes.Buffer
		envelope.Body.Message = in
		enc := xml.NewEncoder(&buf)
		if err := enc.Encode(envelope); err != nil {
			return err
		}
		if err := enc.Flush(); err != nil {
			return err
		}
		body = &buf
	}
	req, err := http.NewRequest(method, uri, body)
	if err != nil {
		return err
	}
	req.Header.Set("SOAPAction", action)
	req = req.WithContext(ctx)
	if c.RequestHook != nil {
		req = c.RequestHook(req)
	}
	httpClient := c.HTTPClient
	if httpClient == nil {
		httpClient = http.DefaultClient
	}
	rsp, err := httpClient.Do(req)
	if err != nil {
		return err
	}
	defer rsp.Body.Close()
	if c.ResponseHook != nil {
		rsp = c.ResponseHook(rsp)
	}
	dec := xml.NewDecoder(rsp.Body)
	envelope.Body.Message = out
	if err := dec.Decode(&envelope); err != nil {
		return err
	}
	if envelope.Body.Fault != nil {
		return fmt.Errorf("%s: %s", envelope.Body.Fault.Code, envelope.Body.Fault.String)
	}
	return nil
}
